

>>>>>tell me if you find bugs or discrepancies or inconsistency <<<<<<




Coding a videogame in javascript, html5 and css: find below in text the tree structure (TREEilprofessore) and I attached to this chat all the modules that compose a videogame called "IL PROFESSORE" is an action adventure with elements of top-down puzzle platformer. "Il Professore" is the protagonist of the game. "Il Professore" Is a Player Character in the style of Mario bros. 
Consider that the createCharacter method is designed to allow for progressive activation of characters. As new functionality are implemented for more characters, their types will be added to the activeCharacters.

Please only answer with effective solutions assuming that all the assests are in place in the right directories, I only want you to focus on Suina1 and Il Professore (do not consider the other characters). There is no need to verify that the code is correctly defined as the code I gave to you is at is it. 
Only focus on the code logic and find the cause that is generating the error then give the solutions:
 
Claude, you are a javascripit master helping me coding and you always follow the rules:
1. Assume All Provided Code is Correct and Present
You will focus solely on logical flow and interactions between the code components without redundantly suggesting corrections to lines or assets I have already confirmed.

2. Focus on Logical Causes Only
You will analyze the problem based on the symptoms (like your error logs or outputs) and provide targeted suggestions for the root cause without assuming missing assets or functionality.

3. Skip Verifications Unless I Request Them
You will avoid generic debugging suggestions (like verifying asset directories or sprite mappings) unless the issue specifically points to those.

4. Consolidate Steps into Clear, Minimal Actions
You'll ensure my responses are precise, avoiding redundant or unnecessary steps, and focus on changes or analysis directly tied to the problem.

5. Every time you write a code for me you rewrite the complete module with the fixes and the updated modifications. Always remember to put on the top of the code as a label the name of the original Module (ie LevelManager.js or main.js or AssetLoader.js etc.)

6. If you're unsure about something, it's okay to admit it. Just say you don’t know.

Don't do anything, just analyze all the files, understand the game and its structure and wait for my next request, answer OK




TREEilprofessore:
Ilprofessore
|   config.js
|   index.html
|   main.js
|
+---assets
|   +---maps
|   |       level1.json
|   |
|   +---sounds
|   |       diego-sound.mp3
|   |       drink.mp3
|   |       milly-sound.mp3
|   |       prof-fuck.mp3
|   |       prof-punch.mp3
|   |       prof-smack.mp3
|   |       prof-step.mp3
|   |       prof-theme.mp3
|   |       suina-evil.mp3
|   |       suina-fuck.mp3
|   |       suina-sound.mp3
|   |       suina-walk.mp3
|   |       urlo.mp3
|   |       walter-sound.mp3
|   |       walter-welcome.mp3
|   |
|   \---sprites
|       |   background.png
|       |   background2.png
|       |   background3.png
|       |   background4.png
|       |   background5.png
|       |   fallback-background.png
|       |   fallback-idle.png
|       |   fallback-spritesheet.png
|       |   professore-idle.png
|       |   professore-spritesheet.png
|       |   skull.png
|       |   skull1.png
|       |
|       +---diego
|       |       diego-attack.png
|       |       diego-idle.png
|       |       diego-spritesheet.png
|       |
|       +---milly
|       |       milly-idle.png
|       |       milly-interact.png
|       |       milly-spritesheet.png
|       |
|       +---professore
|       |       professore-idle.png
|       |       professore-spritesheet.png
|       |
|       +---suina1
|       |       suina1-attack.png
|       |       suina1-idle.png
|       |       suina1-spritesheet.png
|       |
|       +---suina2
|       |       suina2-attack.png
|       |       suina2-idle.png
|       |       suina2-spritesheet.png
|       |
|       +---suinaEvil
|       |       suinaevil-attack.png
|       |       suinaevil-idle.png
|       |       suinaevil-spritesheet.png
|       |
|       \---walter
|               walter-attack.png
|               walter-idle.png
|               walter-spritesheet.png
|
+---characters
|       BaseCharacter.js
|       Diego.js
|       Milly.js
|       Player.js
|       Suina1.js
|       Suina2.js
|       SuinaEvil.js
|       Walter.js
|
+---js
|   \---engine
|           AudioManager.js
|           Camera.js
|           Input.js
|           Renderer.js
|           ScoreAnimation.js
|           ScoreManager.js
|
+---levels
|       LevelManager.js
|
+---styles
|       style.css
|
\---utils
        AssetLoader.js




------------------



main.js:
// main.js
import { CONFIG } from './config.js';
import { Camera } from './js/engine/Camera.js';
import { InputHandler } from './js/engine/Input.js';
import { Player } from './characters/Player.js';
import { Renderer } from './js/engine/Renderer.js';
import { AssetLoader } from './utils/AssetLoader.js';
import { AudioManager } from './js/engine/AudioManager.js';
import { LevelManager } from './levels/LevelManager.js';
import { ScoreManager } from './js/engine/ScoreManager.js';

const audioManager = new AudioManager();
let gameInitialized = false;

// Listen for initial game start
const startGameListener = async (event) => {
    if (!gameInitialized) {
        try {
            if (!audioManager.initialized) {
                await audioManager.init();
            }
            console.log('Starting the game...');
            game.init();
            gameInitialized = true;
            
            // Remove the event listeners once game is started
            window.removeEventListener('click', startGameListener);
            window.removeEventListener('touchstart', startGameListener);
        } catch (error) {
            console.error('Error initializing the game:', error);
        }
    }
};

// Add listeners for initial game start only
window.addEventListener('click', startGameListener);
window.addEventListener('touchstart', startGameListener);

// Prevent unwanted touch behaviors
window.addEventListener('touchmove', (event) => {
    event.preventDefault();
}, { passive: false });

window.addEventListener('gesturestart', (event) => {
    event.preventDefault();
}, { passive: false });

window.addEventListener('gesturechange', (event) => {
    event.preventDefault();
}, { passive: false });

window.addEventListener('gestureend', (event) => {
    event.preventDefault();
}, { passive: false });

function toggleControls() {
    const controlsContainer = document.getElementById('controls-container');
    if (window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT) {
        controlsContainer.style.display = 'flex';
    } else {
        controlsContainer.style.display = 'none';
    }
}

window.addEventListener('load', toggleControls);
window.addEventListener('resize', toggleControls);

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.camera = new Camera(CONFIG.CANVAS.DEFAULT_WIDTH, CONFIG.CANVAS.DEFAULT_HEIGHT);
        this.setupCanvas();

        this.input = new InputHandler();
        this.audioManager = audioManager;
        this.scoreManager = new ScoreManager(this.ctx);

        this.player = new Player(
            CONFIG.WORLD.WIDTH / 2,
            CONFIG.WORLD.HEIGHT / 2,
            CONFIG.PLAYER.WIDTH,
            CONFIG.PLAYER.HEIGHT,
            null,
            'professore'
        );

        window.gameInstance = this;
        window.addEventListener('resize', () => this.setupCanvas());
    }

    setupCanvas() {
        const isMobile = window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT;
        if (isMobile) {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
        } else {
            this.canvas.width = CONFIG.CANVAS.DEFAULT_WIDTH;
            this.canvas.height = CONFIG.CANVAS.DEFAULT_HEIGHT;
            this.canvas.style.width = `${CONFIG.CANVAS.DEFAULT_WIDTH}px`;
            this.canvas.style.height = `${CONFIG.CANVAS.DEFAULT_HEIGHT}px`;
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = '50%';
            this.canvas.style.left = '50%';
            this.canvas.style.transform = 'translate(-50%, -50%)';
        }
        this.camera.width = this.canvas.width;
        this.camera.height = this.canvas.height;
    }

    async init() {
        try {
            const assets = await AssetLoader.loadAssets();
            console.log('Loaded assets:', assets);
            this.assets = assets;
            this.player.sprites = assets.sprites.professore;

            this.levelManager = new LevelManager(assets);
            this.renderer = new Renderer(this.ctx, this.levelManager);

            await this.audioManager.init();

            // Load Level 1 and pass the player object
            this.levelManager.loadLevel(1, this.player);
            this.gameLoop();
        } catch (error) {
            console.error('Game initialization failed:', error);
        }
    }

    update() {
        this.player.update(this.input, {
            width: CONFIG.WORLD.WIDTH,
            height: CONFIG.WORLD.HEIGHT
        });

        this.levelManager.update(
            this.player,
            {
                width: CONFIG.WORLD.WIDTH,
                height: CONFIG.WORLD.HEIGHT
            },
            this.input  // Pass input here
        );

        if (this.levelManager.checkLevelTransition(this.player)) {
            console.log(`Transitioned to Level ${this.levelManager.currentLevel}`);
        }

        this.camera.follow(this.player, CONFIG.WORLD.WIDTH, CONFIG.WORLD.HEIGHT);
        this.audioManager.handleFootsteps(this.player, !this.player.isIdle);
    }

    draw() {
        this.renderer.clear();
        this.renderer.drawBackground(this.levelManager.getCurrentLevelBackground(), this.camera);
        this.renderer.drawCharacters(this.assets.sprites, this.camera);
        this.renderer.drawPlayer(this.player, this.assets.sprites.professore, this.camera);
        
        // Draw score bars last so they're always on top
        this.scoreManager.draw();
    }

    gameLoop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
}

const game = new Game();
game.init().catch(console.error);












index.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Il Professore Game</title>
  <link rel="stylesheet" href="./styles/style.css">
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
	<button id="back-button" type="button">Back</button>
  <div id="controls-container">
    <div id="controls">
      <div class="action-buttons">
        <button type="button" id="bacio" class="action-btn left">B</button>
        <button type="button" id="fuck" class="action-btn right">F</button>
      </div>
      <div class="direction-buttons">
        <button type="button" id="left">←</button>
        <button type="button" id="up">↑</button>
        <button type="button" id="down">↓</button>
        <button type="button" id="right">→</button>
      </div>
    </div>
  </div>
  <script src="./main.js" type="module"></script>
</body>
</html>








config.sys:
// config.js
export const CONFIG = {
    CANVAS: {
        DEFAULT_WIDTH: 800,
        DEFAULT_HEIGHT: 600,
        MOBILE_BREAKPOINT: 768
    },
    WORLD: {
        WIDTH: 800,
        HEIGHT: 600
    },
    PLAYER: {
        WIDTH: 68,
        HEIGHT: 68,
        SPEED: 1,
        TOTAL_FRAMES: 4,
        FRAME_DELAY: 4,
        SPEED_MULTIPLIERS: {
            DESKTOP: 1.0,
            MOBILE: 2.0,
            TABLET: 0.85
        }
    },
    AUDIO: {
        MUSIC_VOLUME: 0.1,
        SFX_VOLUME: 0.3,
        FOOTSTEP_INTERVAL: 300
    },
    LEVELS: {
        1: {
            name: 'StartingLevel',
            backgroundKey: 'background1',
            transitions: {
                TEATRO: { x: { min: 0, max: 150 }, y: { min: 0, max: 100 }, nextLevel: 2 },
                MALAFAMA: { x: { min: 550, max: 800 }, y: { min: 0, max: 100 }, nextLevel: 3 },
                GUSTO: { x: { min: 0, max: 150 }, y: { min: 400, max: 600 }, nextLevel: 4 },
                CHESTER: { x: { min: 600, max: 800 }, y: { min: 450, max: 600 }, nextLevel: 5 }
            }
        },
        2: { name: 'Teatro', backgroundKey: 'background2' },
        3: { name: 'Malafama', backgroundKey: 'background3' },
        4: { name: 'Gusto', backgroundKey: 'background4' },
        5: { name: 'Chester', backgroundKey: 'background5' }
    }
};











assetLoader.js:
// AssetLoader.js
export class AssetLoader {
    static async loadImage(src, fallbackSrc = null) {
        const img = new Image();
        img.src = src;
        return new Promise((resolve, reject) => {
            img.onload = () => resolve(img);
            img.onerror = () => {
                if (fallbackSrc) {
                    console.warn(`Failed to load ${src}, trying fallback: ${fallbackSrc}`);
                    img.src = fallbackSrc;
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load fallback image: ${fallbackSrc}`));
                } else {
                    reject(new Error(`Failed to load image: ${src}`));
                }
            };
        });
    }

    static async loadSound(audioContext, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            return await audioContext.decodeAudioData(arrayBuffer);
        } catch (error) {
            console.error(`Failed to load sound: ${url}`, error);
            throw new Error(`Failed to load sound: ${url}`);
        }
    }

    static async loadAssets() {
        try {
            const audioContext = new AudioContext(); 
            const [
                professoreidle,
                professorewalking,
                millyidle,
                millyspritesheet,
                millyinteract,
                suina1idle,
                suina1walking,
                suina1attack,
                suina2idle,
                suina2walking,
                suina2attack,
                suinaevilidle,
                suinaevilwalking,
                suinaevilattack,
                walteridle,
                walterwalking,
                walterattack,
                diegoidle,
                diegowalking,
                diegoattack,
                background1,
                background2,
                background3,
                background4,
                background5,
                proffuck,
                profpunch,
                profsmack,
                profstep,
                proftheme,
                suinafuck,
                suinasound,
                suinaevil,
                suinawalk,
                waltersound,
                walterwelcome,
                diegosound,
                millysound
            ] = await Promise.all([
                this.loadImage('./assets/sprites/professore/professore-idle.png'),
                this.loadImage('./assets/sprites/professore/professore-spritesheet.png'),
                this.loadImage('./assets/sprites/milly/milly-idle.png'),
                this.loadImage('./assets/sprites/milly/milly-spritesheet.png'),
                this.loadImage('./assets/sprites/milly/milly-interact.png'),
                this.loadImage('./assets/sprites/suina1/suina1-idle.png'),
                this.loadImage('./assets/sprites/suina1/suina1-spritesheet.png'),
                this.loadImage('./assets/sprites/suina1/suina1-attack.png'),
                this.loadImage('./assets/sprites/suina2/suina2-idle.png'),
                this.loadImage('./assets/sprites/suina2/suina2-spritesheet.png'),
                this.loadImage('./assets/sprites/suina2/suina2-attack.png'),
                this.loadImage('./assets/sprites/suinaEvil/suinaevil-idle.png'),
                this.loadImage('./assets/sprites/suinaEvil/suinaevil-spritesheet.png'),
                this.loadImage('./assets/sprites/suinaEvil/suinaevil-attack.png'),
                this.loadImage('./assets/sprites/walter/walter-idle.png'),
                this.loadImage('./assets/sprites/walter/walter-spritesheet.png'),
                this.loadImage('./assets/sprites/walter/walter-attack.png'),
                this.loadImage('./assets/sprites/diego/diego-idle.png'),
                this.loadImage('./assets/sprites/diego/diego-spritesheet.png'),
                this.loadImage('./assets/sprites/diego/diego-attack.png'),
                this.loadImage('./assets/sprites/background.png'),
                this.loadImage('./assets/sprites/background2.png'),
                this.loadImage('./assets/sprites/background3.png'),
                this.loadImage('./assets/sprites/background4.png'),
                this.loadImage('./assets/sprites/background5.png'),
                this.loadSound(audioContext, './assets/sounds/prof-fuck.mp3'),
                this.loadSound(audioContext, './assets/sounds/prof-punch.mp3'),
                this.loadSound(audioContext, './assets/sounds/prof-smack.mp3'),
                this.loadSound(audioContext, './assets/sounds/prof-step.mp3'),
                this.loadSound(audioContext, './assets/sounds/prof-theme.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-fuck.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-sound.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-evil.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-walk.mp3'),
                this.loadSound(audioContext, './assets/sounds/walter-sound.mp3'),
                this.loadSound(audioContext, './assets/sounds/walter-welcome.mp3'),
                this.loadSound(audioContext, './assets/sounds/diego-sound.mp3'),
                this.loadSound(audioContext, './assets/sounds/milly-sound.mp3')
            ]);

            return {
                sprites: {
                    professore: { idle: professoreidle, walking: professorewalking },
                    milly: { idle: millyidle, spritesheet: millyspritesheet, interact: millyinteract },
                    suina1: { idle: suina1idle, walking: suina1walking, attack: suina1attack },
                    suina2: { idle: suina2idle, walking: suina2walking, attack: suina2attack },
                    suinaevil: { idle: suinaevilidle, walking: suinaevilwalking, attack: suinaevilattack },
                    walter: { idle: walteridle, walking: walterwalking, attack: walterattack },
                    diego: { idle: diegoidle, walking: diegowalking, attack: diegoattack }
                },
                backgrounds: {
                    background1,
                    background2,
                    background3,
                    background4,
                    background5
                },
                sounds: {
                    proffuck,
                    profpunch,
                    profsmack,
                    profstep,
                    proftheme,
                    suinafuck,
                    suinasound,
                    suinaevil,
                    suinawalk,
                    waltersound,
                    walterwelcome,
                    diegosound,
                    millysound
                },
                audioContext
            };
        } catch (error) {
            console.error('Error loading assets:', error);
            throw new Error('Failed to load assets.');
        }
    }
}














style.css:
/* style.css */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  overflow: hidden;
  height: 100%;
  width: 100%;
}

canvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: block;
  background-color: #f0f0f0;
}

@media (max-width: 768px) {
  canvas {
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0;
    left: 0;
    transform: none;
  }
}


/* Back button styling */
#back-button {
  position: fixed;
  top: 20px;
  left: 20px;
  padding: 10px 20px;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 5px;
  font-size: 16px;
  cursor: pointer;
  z-index: 1000;
  transition: all 0.3s ease;
  display: none; /* Initially hidden */
}

#back-button:hover {
  background-color: rgba(0, 0, 0, 0.7);
}

@media (max-width: 768px) {
  #back-button {
    top: 10px;
    left: 10px;
    padding: 8px 16px;
    font-size: 14px;
  }
}


#controls-container {
  position: fixed;
  bottom: 20px;
  width: 100%;
  display: flex;
  justify-content: center;
  z-index: 10;
  pointer-events: none;
}

#controls {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  pointer-events: auto;
}

.action-buttons {
  position: absolute;
  width: 100%;
  display: flex;
  justify-content: space-between;
  padding: 0 5px; /* 5px padding from screen edges */
  bottom: 80px; /* Position above direction buttons */
}

.direction-buttons {
  display: flex;
  justify-content: center;
  gap: 5px;
  padding: 0 20px;
}

#controls button {
  width: 70px;
  height: 70px;
  font-size: 24px;
  border: none;
  border-radius: 50%;
  background-color: rgba(51, 51, 51, 0.8);
  color: white;
  transition: all 0.2s ease;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#controls .action-btn {
  width: 60px;
  height: 60px;
  font-weight: bold;
  background-color: rgba(76, 175, 80, 0.8);  /* Green tint for action buttons */
}

#controls button:active,
#controls button.active {
  transform: scale(0.9);
  background-color: rgba(76, 76, 76, 0.9);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

#controls .action-btn:active,
#controls .action-btn.active {
  background-color: rgba(56, 142, 60, 0.9);  /* Darker green when pressed */
}

@media (min-width: 769px) {
  #controls-container {
    display: none;
  }
}

/* Prevent text selection on mobile */
#controls button {
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

/* Ensure buttons don't cause scrolling on iOS */
#controls-container {
  touch-action: none;
}














AudioManager.js:
// AudioManager.js
import { CONFIG } from '../../config.js';

export class AudioManager {
    constructor() {
        this.sounds = {};
        this.music = {};
        this.audioContext = null;
        this.musicGainNode = null;
        this.sfxGainNode = null;
        this.currentMusicSource = null;
        this.initialized = false;
    }

    async init() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.musicGainNode = this.audioContext.createGain();
            this.sfxGainNode = this.audioContext.createGain();
            this.musicGainNode.connect(this.audioContext.destination);
            this.sfxGainNode.connect(this.audioContext.destination);

            this.musicGainNode.gain.setValueAtTime(CONFIG.AUDIO.MUSIC_VOLUME, this.audioContext.currentTime);
            this.sfxGainNode.gain.setValueAtTime(CONFIG.AUDIO.SFX_VOLUME, this.audioContext.currentTime);

            await this.ensureAudioContextResume();
            await this.loadAllSounds();
            this.initialized = true;
            console.log('AudioManager initialized successfully.');

            if (this.music['prof-theme']) {
                this.playBackgroundMusic();
            } else {
                console.warn('Theme music is not loaded.');
            }
        } catch (error) {
            console.error('AudioManager initialization failed:', error);
        }
    }

    async ensureAudioContextResume() {
        if (this.audioContext.state === 'suspended') {
            return new Promise((resolve) => {
                const resumeAudio = () => {
                    this.audioContext.resume().then(() => {
                        console.log('AudioContext resumed.');
                        window.removeEventListener('click', resumeAudio);
                        window.removeEventListener('keydown', resumeAudio);
                        resolve();
                    }).catch((error) => {
                        console.error('Failed to resume AudioContext:', error);
                    });
                };
                window.addEventListener('click', resumeAudio);
                window.addEventListener('keydown', resumeAudio);
            });
        }
    }

    async loadAllSounds() {
        console.log('Loading sounds...');
        try {
            await Promise.all([
                this.loadSound('prof-theme', './assets/sounds/prof-theme.mp3', 'music'),
                this.loadSound('professore_step', './assets/sounds/prof-step.mp3', 'sfx'),
                this.loadSound('professore_fuck', './assets/sounds/prof-fuck.mp3', 'sfx'),
                this.loadSound('professore_smack', './assets/sounds/prof-smack.mp3', 'sfx'),
                this.loadSound('professore_punch', './assets/sounds/prof-punch.mp3', 'sfx'),
                this.loadSound('walter_welcome', './assets/sounds/walter-welcome.mp3', 'sfx'),
                this.loadSound('walter_sound', './assets/sounds/walter-sound.mp3', 'sfx'),
                this.loadSound('suina_walk', './assets/sounds/suina-walk.mp3', 'sfx'),
                this.loadSound('suina_sound', './assets/sounds/suina-sound.mp3', 'sfx'),
                this.loadSound('suina_fuck', './assets/sounds/suina-fuck.mp3', 'sfx'),
                this.loadSound('suina_evil', './assets/sounds/suina-evil.mp3', 'sfx'),
                this.loadSound('milly_sound', './assets/sounds/milly-sound.mp3', 'sfx'),
                this.loadSound('diego_sound', './assets/sounds/diego-sound.mp3', 'sfx')
            ]);
            console.log('All sounds loaded successfully.');
        } catch (error) {
            console.error('Failed to load some sounds:', error);
        }
    }

    async loadSound(key, url, type = 'sfx') {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

            if (type === 'music') {
                this.music[key] = audioBuffer;
            } else {
                this.sounds[key] = audioBuffer;
            }
            console.log(`Sound loaded: ${key} (${type})`);
        } catch (error) {
            console.error(`Failed to load sound: ${key} from ${url}`, error);
            throw new Error(`Failed to load sound: ${key}`);
        }
    }

    playBackgroundMusic() {
        if (!this.initialized || !this.music['prof-theme']) {
            console.warn('Background music not initialized or theme music not loaded.', {
                initialized: this.initialized,
                themeLoaded: !!this.music['prof-theme']
            });
            return;
        }

        if (this.currentMusicSource) {
            this.currentMusicSource.stop();
        }

        this.currentMusicSource = this.audioContext.createBufferSource();
        this.currentMusicSource.buffer = this.music['prof-theme'];
        this.currentMusicSource.loop = true;
        this.currentMusicSource.connect(this.musicGainNode);
        this.currentMusicSource.start(0);
        console.log('Background music started.');
    }

    playSound(key, type = 'sfx') {
        if (!this.initialized) {
            console.warn('AudioManager not initialized.');
            return;
        }

        const buffer = type === 'music' ? this.music[key] : this.sounds[key];
        if (!buffer) {
            console.warn(`Sound not found: ${key}`);
            return;
        }

        const source = this.audioContext.createBufferSource();
        source.buffer = buffer;
        const gainNode = type === 'music' ? this.musicGainNode : this.sfxGainNode;
        source.connect(gainNode);
        source.start();
        console.log(`Playing sound: ${key}`);
    }

    handleFootsteps(player, isMoving) {
        if (isMoving) {
            const now = Date.now();
            if (!this.lastFootstepTime || now - this.lastFootstepTime > CONFIG.AUDIO.FOOTSTEP_INTERVAL) {
                this.playSound('professore_step');
                this.lastFootstepTime = now;
            }
        }
    }

    setMusicVolume(volume) {
        if (this.musicGainNode) {
            this.musicGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        }
    }

    setSFXVolume(volume) {
        if (this.sfxGainNode) {
            this.sfxGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        }
    }
}












Camera.js:
// Camera.js
import { CONFIG } from '../../config.js';

export class Camera {
    constructor(width, height) {
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.height = height;
    }

    follow(target, worldWidth, worldHeight) {
        const idealX = target.x + target.width / 2 - this.width / 2;
        const idealY = target.y + target.height / 2 - this.height / 2;

        this.x = this.clamp(idealX, 0, Math.max(0, worldWidth - this.width));
        this.y = this.clamp(idealY, 0, Math.max(0, worldHeight - this.height));

        if (worldWidth < this.width) {
            this.x = 0;
        }
        if (worldHeight < this.height) {
            this.y = 0;
        }
    }

    clamp(value, min, max) {
        return Math.max(min, Math.min(value, max));
    }
}








Input.js:
// Input.js
import { CONFIG } from '../../config.js';

export class InputHandler {
    constructor() {
        this.keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyF: false,
            KeyB: false
        };

        this.isMobile = window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT ||
            /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        this.touchState = {};
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Keyboard events
        window.addEventListener('keydown', (e) => this.setKey(e.code, true));
        window.addEventListener('keyup', (e) => this.setKey(e.code, false));

        if (this.isMobile) {
            this.setupTouchControls();
        }
    }

    setupTouchControls() {
        // Direction buttons
        const directions = ['up', 'down', 'left', 'right'];
        directions.forEach((dir) => {
            const element = document.getElementById(dir);
            if (element) {
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, true);
                });
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, false);
                });
                element.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, false);
                });
            }
        });

        // Action buttons
        const actionButtons = {
            'bacio': 'KeyB',
            'fuck': 'KeyF'
        };

        Object.entries(actionButtons).forEach(([buttonId, keyCode]) => {
            const element = document.getElementById(buttonId);
            if (element) {
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, true);
                    element.classList.add('active');
                });
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, false);
                    element.classList.remove('active');
                });
                element.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, false);
                    element.classList.remove('active');
                });
            }
        });
    }

    handleDirectionTouch(event, direction, isPressed) {
        const key = `Arrow${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
        this.setKey(key, isPressed);
        const element = document.getElementById(direction);
        if (element) {
            element.classList.toggle('active', isPressed);
        }
    }

    handleActionTouch(keyCode, isPressed) {
        this.setKey(keyCode, isPressed);
    }

    setKey(key, value) {
        if (this.keys.hasOwnProperty(key)) {
            this.keys[key] = value;
        }
    }

    isMoving() {
        return this.keys.ArrowUp || this.keys.ArrowDown || 
               this.keys.ArrowLeft || this.keys.ArrowRight;
    }
}









Renderer.js:
// Renderer.js
import { CONFIG } from '../../config.js';

export class Renderer {
    constructor(ctx, levelManager) {
        this.ctx = ctx;
        this.levelManager = levelManager;
        this.directions = { down: 0, left: 1, right: 2, up: 3 };
    }

    clear() {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }

    drawBackground(background, camera) {
        if (background) {
            this.ctx.drawImage(
                background,
                camera.x, camera.y,
                camera.width, camera.height,
                0, 0,
                camera.width, camera.height
            );
        } else {
            console.warn('Background image is undefined.');
        }
    }

    drawPlayer(player, sprites, camera) {
        const drawX = player.x - camera.x;
        const drawY = player.y - camera.y;

        if (player.isIdle) {
            if (sprites.idle) {
                this.ctx.drawImage(sprites.idle, drawX, drawY, player.width, player.height);
            } else {
                console.error('Player idle sprite is undefined.');
            }
        } else {
            const directionIndex = this.directions[player.direction] !== undefined 
                ? this.directions[player.direction] 
                : this.directions['down'];
            const spriteX = player.frame * player.width;
            const spriteY = directionIndex * player.height;

            if (sprites.walking) {
                this.ctx.drawImage(
                    sprites.walking,
                    spriteX, spriteY,
                    player.width, player.height,
                    drawX, drawY,
                    player.width, player.height
                );
            } else {
                console.error('Player walking sprite is undefined.');
            }
        }
    }

       drawCharacters(sprites, camera) {
        this.levelManager.characters.forEach((character) => {
            if (!character || !character.type || !sprites[character.type]) {
                console.error(`Sprites for character type ${character ? character.type : 'undefined'} are undefined.`);
                return;
            }

            const drawX = character.x - camera.x;
            const drawY = character.y - camera.y;

            const characterSprites = sprites[character.type.toLowerCase()];

            // Handle special attack sprite state for Suina1
            if (character.type === 'suina1' && character.currentSprite === 'attack' && character.activeSprite) {
                this.ctx.drawImage(character.activeSprite, drawX, drawY, character.width, character.height);
                return;
            }

            if (character.isIdle) {
                if (characterSprites.idle) {
                    this.ctx.drawImage(characterSprites.idle, drawX, drawY, character.width, character.height);
                }
            } else {
                const directionIndex = this.directions[character.direction] !== undefined
                    ? this.directions[character.direction]
                    : this.directions['down'];
                const spriteX = character.frame * character.width;
                const spriteY = directionIndex * character.height;

                if (characterSprites.walking) {
                    this.ctx.drawImage(
                        characterSprites.walking,
                        spriteX, spriteY,
                        character.width, character.height,
                        drawX, drawY,
                        character.width, character.height
                    );
                }
            }
        });
    }
}









ScoreManager.js:
// ScoreManager.js
import { ScoreAnimation } from './ScoreAnimation.js';

export class ScoreManager {
    constructor(ctx) {
        this.ctx = ctx;
        this.scores = {
            energy: 0,
            love: 0,
            friendship: 0
        };
        this.maxScore = 100;
        this.barWidth = 150;
        this.barHeight = 10;
        this.padding = 10;
        this.colors = {
            energy: '#ff4444',    // Red for Energy
            love: '#ff69b4',      // Pink for Love
            friendship: '#4CAF50'  // Green for Friendship
        };
        this.barSpacing = 5;
        this.textPadding = 5;
        
        // Initialize score animation system
        this.scoreAnimation = new ScoreAnimation();
    }

    increaseScore(type, amount) {
        if (this.scores.hasOwnProperty(type)) {
            const oldScore = this.scores[type];
            this.scores[type] = Math.min(this.maxScore, oldScore + amount);
            
            // If it's a love score increase, trigger animation
            if (type === 'love' && amount > 0) {
                this.scoreAnimation.addAnimation(amount);
            }
        }
    }

    draw() {
        this.ctx.save();

        // Draw score bars
        Object.entries(this.scores).forEach(([type, score], index) => {
            const x = this.ctx.canvas.width - this.barWidth - this.padding;
            const y = this.padding + (index * (this.barHeight + this.barSpacing));

            // Draw label with shadow for better visibility
            this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            this.ctx.shadowBlur = 2;
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = 'bold 10px Arial';
            this.ctx.textAlign = 'right';
            this.ctx.fillText(type.toUpperCase(), x - this.textPadding, y + this.barHeight);
            
            // Reset shadow for bars
            this.ctx.shadowBlur = 0;

            // Draw background bar with slight transparency
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            this.ctx.fillRect(x, y, this.barWidth, this.barHeight);

            // Draw score bar
            this.ctx.fillStyle = this.colors[type];
            const fillWidth = (score / this.maxScore) * this.barWidth;
            this.ctx.fillRect(x, y, fillWidth, this.barHeight);
        });

        // Draw any active score animations
        this.scoreAnimation.update(this.ctx);

        this.ctx.restore();
    }
}








ScoreAnimation.js:
// ScoreAnimation.js
export class ScoreAnimation {
    constructor() {
        this.animations = [];
    }

    addAnimation(score) {
        // Get canvas dimensions directly from the game canvas
        const canvas = document.getElementById('gameCanvas');
        const centerX = Math.round(canvas.width / 2);
        const centerY = Math.round(canvas.height / 2);
        
        console.log('Canvas dimensions:', {
            width: canvas.width,
            height: canvas.height,
            centerX: centerX,
            centerY: centerY
        });

        this.animations.push({
            score: `+${score}`,
            x: centerX,         // Center X
            y: centerY,         // Center Y
            startTime: performance.now(),
            duration: 2000,     // 2 seconds
            startFontSize: 72,  // Starting size
            endFontSize: 24,    // Ending size
            opacity: 1
        });
    }

    update(ctx) {
        const currentTime = performance.now();
        
        for (let i = this.animations.length - 1; i >= 0; i--) {
            const anim = this.animations[i];
            const elapsed = currentTime - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);

            // Smooth easing function
            const easeOutCubic = 1 - Math.pow(1 - progress, 3);

            // Calculate current font size
            const fontSize = Math.round(anim.startFontSize + (anim.endFontSize - anim.startFontSize) * easeOutCubic);
            
            // Calculate opacity (fade out in the last 30% of animation)
            anim.opacity = progress > 0.7 ? 1 - ((progress - 0.7) / 0.3) : 1;

            // Draw score with debug info
            ctx.save();
            
            // Set text properties
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Draw debug point at center (temporary)
            ctx.fillStyle = 'red';
            ctx.fillRect(anim.x - 2, anim.y - 2, 4, 4);
            
            // Move upward as it fades
            const yOffset = 50 * easeOutCubic;

            // Draw text outline
            ctx.strokeStyle = `rgba(0, 0, 0, ${anim.opacity * 0.5})`;
            ctx.lineWidth = 3;
            ctx.strokeText(anim.score, anim.x, anim.y - yOffset);

            // Draw text fill
            ctx.fillStyle = `rgba(255, 192, 203, ${anim.opacity})`;
            ctx.fillText(anim.score, anim.x, anim.y - yOffset);

            ctx.restore();

            // Remove finished animations
            if (progress >= 1) {
                this.animations.splice(i, 1);
            }
        }
    }
}












Levelmanager.js:
// LevelManager.js
import { CONFIG } from '../config.js';
import { Suina1 } from '../characters/Suina1.js';
import { Suina2 } from '../characters/Suina2.js';
import { SuinaEvil } from '../characters/SuinaEvil.js';
import { Walter } from '../characters/Walter.js';
import { Diego } from '../characters/Diego.js';
import { Milly } from '../characters/Milly.js';

export class LevelManager {
    constructor(assets) {
        this.assets = assets;
        this.currentLevel = 1;
        this.characters = [];
        this.characterTimers = {};
        this.player = null;
        this.transitionInProgress = false;
        this.transitionTimeout = null;
        this.setupBackButton();
    }

    setupBackButton() {
        const backButton = document.getElementById('back-button');
        if (!backButton) return;

        // Handle back button click
        backButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (this.currentLevel !== 1) {
                this.transitionToLevel1();
            }
        });

        // Initial visibility
        this.updateBackButtonVisibility();
    }

    updateBackButtonVisibility() {
        const backButton = document.getElementById('back-button');
        if (backButton) {
            backButton.style.display = this.currentLevel === 1 ? 'none' : 'block';
        }
    }

    transitionToLevel1() {
        // Clear any existing timers
        this.clearTimers();
        
        // Reset player position to center of level 1
        if (this.player) {
            this.player.x = CONFIG.WORLD.WIDTH / 2;
            this.player.y = CONFIG.WORLD.HEIGHT / 2;
        }

        // Load level 1
        this.loadLevel(1, this.player);
        
        // Update back button visibility
        this.updateBackButtonVisibility();
    }

    loadLevel(levelNumber, player) {
        const levelConfig = CONFIG.LEVELS[levelNumber];
        if (!levelConfig) {
            console.error(`Level ${levelNumber} configuration not found.`);
            return;
        }

        if (this.transitionTimeout) {
            clearTimeout(this.transitionTimeout);
        }

        this.transitionInProgress = true;

        // Store character states before clearing
        const storedStates = new Map();
        this.characters.forEach(char => {
            if (char && char.type) {
                storedStates.set(char.type, {
                    direction: char.direction,
                    lastNonIdleDirection: char.lastNonIdleDirection,
                    isIdle: false
                });
            }
        });

        this.clearTimers();
        this.characters = [];
        this.characterTimers = {};

        this.currentLevel = levelNumber;
        this.loadCharactersForLevel(levelNumber, storedStates);
        this.updateBackButtonVisibility();

        if (this.player !== player) {
            this.player = player;
        }

        this.resetPlayerState();

        console.log(`Loaded level ${levelNumber}`);

        this.transitionTimeout = setTimeout(() => {
            this.transitionInProgress = false;
            // Force walking state after transition
            this.characters.forEach(char => {
                if (char) char.isIdle = false;
            });
        }, 100);
    }

    resetPlayerState() {
        if (!this.player) return;

        // Preserve timing consistency
        const now = performance.now();
        this.player.lastUpdateTime = now;
        this.player.lastAnimationUpdate = now;
        this.player.frameTime = now;

        this.player.updateSpeedMultiplier();
        
        // Reset movement tracking
        this.player.velocity = { x: 0, y: 0 };
        this.player.movementBuffer = { x: 0, y: 0 };

        this.player.x = CONFIG.WORLD.WIDTH / 2;
        this.player.y = CONFIG.WORLD.HEIGHT / 2;

        this.player.frame = this.player.frame % this.player.totalFrames;
    }

    loadCharactersForLevel(levelNumber, storedStates) {
        switch (levelNumber) {
            case 1:
                this.addRandomCharacter('milly', 10000);
                break;
            case 2:
                this.addCharacter('suina1', 300, 200, storedStates);
                this.addDelayedCharacter('suina2', 400, 250, 5000);
                this.addDelayedCharacter('suinaevil', 500, 100, 6000);
                break;
            case 3:
                this.addCharacter('suina1', 350, 300, storedStates);
                this.addDelayedCharacter('suina2', 400, 200, 5000);
                this.addDelayedCharacter('suinaevil', 450, 150, 6000);
                break;
            case 4:
                this.addCharacter('walter', 600, 300);
                break;
            case 5:
                this.addCharacter('diego', 700, 400);
                break;
            default:
                console.warn(`No characters defined for level ${levelNumber}`);
                break;
        }
    }

    addCharacter(type, x, y, storedStates = null) {
        const characterClasses = {
            suina1: Suina1,
            suina2: Suina2,
            suinaevil: SuinaEvil,
            walter: Walter,
            diego: Diego,
            milly: Milly
        };

        const CharacterClass = characterClasses[type.toLowerCase()];
        const sprites = this.assets.sprites[type];

        if (!CharacterClass || !sprites) {
            console.error(`Invalid character type or missing sprites: ${type}`);
            return;
        }

        const character = new CharacterClass(x, y, CONFIG.PLAYER.WIDTH, CONFIG.PLAYER.HEIGHT, sprites, type.toLowerCase());

        // Restore previous state if available
        if (storedStates) {
            const storedState = storedStates.get(type.toLowerCase());
            if (storedState) {
                Object.assign(character, storedState);
            }
        }

        // Ensure character starts in walking state
        character.isIdle = false;

        this.characters.push(character);
    }

    addDelayedCharacter(type, x, y, delay) {
        if (!this.assets.sprites[type]) {
            console.error(`Cannot add delayed character: Missing sprites for type ${type}`);
            return;
        }
        this.characterTimers[type] = setTimeout(() => {
            this.addCharacter(type, x, y);
            delete this.characterTimers[type];
        }, delay);
    }

    addRandomCharacter(type, interval) {
        const spawnRandomly = () => {
            if (this.currentLevel !== 1) return;
            const x = Math.random() * (CONFIG.WORLD.WIDTH - CONFIG.PLAYER.WIDTH);
            const y = Math.random() * (CONFIG.WORLD.HEIGHT - CONFIG.PLAYER.HEIGHT);
            this.addCharacter(type, x, y);
        };

        this.characterTimers[type] = setInterval(spawnRandomly, interval);
    }

    update(player, worldBounds, input) {
        if (this.transitionInProgress) return;

        this.characters = this.characters.filter(character => character && character.type);

        this.characters.forEach((character) => {
            if (!character.isCaught) {
                character.update(player, {
                    width: CONFIG.WORLD.WIDTH,
                    height: CONFIG.WORLD.HEIGHT
                }, input);
            }
        });
    }

    checkLevelTransition(player) {
        if (this.transitionInProgress) return false;

        const currentLevelConfig = CONFIG.LEVELS[this.currentLevel];
        if (!currentLevelConfig || !currentLevelConfig.transitions) {
            return false;
        }

        for (const transition of Object.values(currentLevelConfig.transitions)) {
            if (
                player.x >= transition.x.min &&
                player.x <= transition.x.max &&
                player.y >= transition.y.min &&
                player.y <= transition.y.max
            ) {
                const nextLevel = transition.nextLevel;
                this.loadLevel(nextLevel, player);
                return true;
            }
        }

        return false;
    }

    clearTimers() {
        for (const timer in this.characterTimers) {
            clearTimeout(this.characterTimers[timer]);
            clearInterval(this.characterTimers[timer]);
        }
        this.characterTimers = {};
    }

    getCurrentLevelBackground() {
        const levelConfig = CONFIG.LEVELS[this.currentLevel];
        if (!levelConfig) {
            console.error(`Level ${this.currentLevel} configuration not found.`);
            return null;
        }

        const backgroundKey = levelConfig.backgroundKey;
        return this.assets.backgrounds[backgroundKey];
    }
}






BaseCharacter.js:
// BaseCharacter.js
import { CONFIG } from '../config.js';

export class BaseCharacter {
    constructor(x, y, width, height, sprites, type, speedMultiplier = 1) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.sprites = sprites;
        this.type = type.toLowerCase();

        // Movement and animation
        this.speed = CONFIG.PLAYER.SPEED * speedMultiplier;
        this.direction = 'down';
        this.isIdle = true;
        this.frame = 0;
        this.totalFrames = CONFIG.PLAYER.TOTAL_FRAMES;
        this.animationSpeed = 100;
        this.lastAnimationUpdate = 0;
        this.isCaught = false;

        this.lastUpdateTime = performance.now();
    }

    update(player, worldBounds, input) {  // Add input parameter here
        if (this.isCaught) return;

        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastUpdateTime) / 16.67;
        this.lastUpdateTime = currentTime;

        // Pass input to updateBehavior
        this.updateBehavior(player, worldBounds, deltaTime, input);

        if (!this.isIdle) {
            if (currentTime - this.lastAnimationUpdate >= this.animationSpeed) {
                this.frame = (this.frame + 1) % this.totalFrames;
                this.lastAnimationUpdate = currentTime;
            }
        } else {
            this.frame = 0;
            this.lastAnimationUpdate = 0;
        }
    }

    updateBehavior(player, worldBounds, deltaTime, input) {  // Add input parameter here
        this.isIdle = true;
    }

    checkCollision(other) {
        return (
            this.x < other.x + other.width &&
            this.x + this.width > other.x &&
            this.y < other.y + other.height &&
            this.y + this.height > other.y
        );
    }
}












Player.js:
// Player.js
import { CONFIG } from '../config.js';
import { BaseCharacter } from './BaseCharacter.js';

export class Player extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
        this.lastUpdateTime = performance.now();
        this.frameTime = performance.now();
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.currentInput = null;
        this.updateSpeedMultiplier();
        this.spriteState = {
            current: 'idle',
            frame: 0,
            lastUpdate: performance.now()
        };
    }

    forceStateUpdate() {
        const now = performance.now();
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.lastAnimationUpdate = now;
        this.spriteState.lastUpdate = now;
        
        // Update sprite state based on current movement
        this.updateSpriteState(!this.isIdle);
    }

    updateSpriteState(isMoving) {
        const now = performance.now();
        const spriteType = isMoving ? 'walking' : 'idle';
        
        // Only update if state actually changed
        if (this.spriteState.current !== spriteType) {
            this.spriteState.current = spriteType;
            this.spriteState.frame = 0;
            this.spriteState.lastUpdate = now;
            this.frame = 0; // Reset animation frame
        }
    }

    determineSpeedMultiplier() {
        const screenWidth = window.innerWidth;
        if (screenWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT) {
            return CONFIG.PLAYER.SPEED_MULTIPLIERS.MOBILE;
        } else if (screenWidth <= 1024) {
            return CONFIG.PLAYER.SPEED_MULTIPLIERS.TABLET;
        }
        return CONFIG.PLAYER.SPEED_MULTIPLIERS.DESKTOP;
    }

    updateSpeedMultiplier() {
        this.speedMultiplier = this.determineSpeedMultiplier();
        this.speed = CONFIG.PLAYER.SPEED * this.speedMultiplier;
    }

    update(input, worldBounds) {
        const currentTime = performance.now();
        
        // Limit deltaTime to prevent extreme values
        const maxDeltaTime = 32;
        const rawDeltaTime = (currentTime - this.lastUpdateTime) / 16.67;
        const deltaTime = Math.min(rawDeltaTime, maxDeltaTime);
        
        this.lastUpdateTime = currentTime;
        this.frameTime += deltaTime * 16.67;

        // Store previous state
        const wasMoving = !this.isIdle;
        
        // Update movement and state
        this.updateBehavior(input, worldBounds, deltaTime);
        
        // Check if movement state changed
        const isMoving = !this.isIdle;
        if (wasMoving !== isMoving) {
            this.updateSpriteState(isMoving);
        }

        // Update animation
        if (isMoving) {
            if (currentTime - this.spriteState.lastUpdate >= this.animationSpeed) {
                this.frame = (this.frame + 1) % this.totalFrames;
                this.spriteState.lastUpdate = currentTime;
            }
        }
    }

    updateBehavior(input, worldBounds, deltaTime) {
        // Store current input for state preservation
        this.currentInput = { ...input.keys };
        
        const moving = input.isMoving();
        this.isIdle = !moving;

        if (moving) {
            const adjustedSpeed = this.speed * deltaTime;
            const keys = input.keys;
            
            // Reset velocity
            this.velocity.x = 0;
            this.velocity.y = 0;

            // Calculate velocity based on input
            if (keys.ArrowRight) {
                this.velocity.x = adjustedSpeed;
                this.direction = 'right';
            }
            if (keys.ArrowLeft) {
                this.velocity.x = -adjustedSpeed;
                this.direction = 'left';
            }
            if (keys.ArrowDown) {
                this.velocity.y = adjustedSpeed;
                this.direction = 'down';
            }
            if (keys.ArrowUp) {
                this.velocity.y = -adjustedSpeed;
                this.direction = 'up';
            }

            // Add to movement buffer
            this.movementBuffer.x += this.velocity.x;
            this.movementBuffer.y += this.velocity.y;

            // Apply whole pixel movements
            const newX = this.x + Math.round(this.movementBuffer.x);
            const newY = this.y + Math.round(this.movementBuffer.y);

            // Clamp to world bounds
            this.x = Math.min(Math.max(newX, 0), worldBounds.width - this.width);
            this.y = Math.min(Math.max(newY, 0), worldBounds.height - this.height);

            // Remove used movement from buffer
            this.movementBuffer.x -= Math.round(this.movementBuffer.x);
            this.movementBuffer.y -= Math.round(this.movementBuffer.y);

            // Update last position
            this.lastX = this.x;
            this.lastY = this.y;
        } else {
            // Reset movement buffer when idle
            this.movementBuffer.x = 0;
            this.movementBuffer.y = 0;
        }
    }
}








// Suina1.js
// Suina1.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class Suina1 extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 1.5);
        this.moveTimer = 0;
        this.changeDirectionInterval = 2500;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = performance.now();
        this.frameTime = performance.now();
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = performance.now();

        // Collision and interaction states
        this.isColliding = false;
        this.collisionStartTime = null;
        this.isDisappearing = false;
        this.hasChangedSprite = false;
        this.buttonInteractionAvailable = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.respawnTimeout = null;
    }

    respawn() {
        // Generate random coordinates within the world bounds
        const padding = 50; // To avoid spawning too close to edges
        this.x = Math.random() * (CONFIG.WORLD.WIDTH - this.width - padding * 2) + padding;
        this.y = Math.random() * (CONFIG.WORLD.HEIGHT - this.height - padding * 2) + padding;
        
        // Reset all states
        this.isColliding = false;
        this.collisionStartTime = null;
        this.isDisappearing = false;
        this.hasChangedSprite = false;
        this.buttonInteractionAvailable = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.isCaught = false;
        this.currentSprite = null;
        this.activeSprite = null;

        // Reset movement parameters
        this.moveTimer = performance.now();
        this.lastDirectionChange = performance.now();
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.isIdle = false;
        
        // Set a random initial direction
        const directions = ['up', 'down', 'left', 'right'];
        this.direction = directions[Math.floor(Math.random() * directions.length)];
        this.lastNonIdleDirection = this.direction;
    }

    handleCollision(player, input) {
        const currentTime = performance.now();
        const gameInstance = window.gameInstance;

        // Initial collision detection
        if (!this.isColliding && !this.isDisappearing && this.isVisible) {
            this.isColliding = true;
            this.collisionStartTime = currentTime;
            this.hasChangedSprite = true;
            this.buttonInteractionAvailable = true;

            // Play initial collision sound
            if (!this.soundPlayed && gameInstance.audioManager) {
                gameInstance.audioManager.playSound('suina_sound');
                this.soundPlayed = true;
            }

            // Change to attack sprite
            if (this.sprites.attack) {
                this.currentSprite = 'attack';
                this.activeSprite = this.sprites.attack;

                // Set timer for disappearance after 2 seconds
                setTimeout(() => {
                    this.isVisible = false;
                    this.isDisappearing = true;
                    this.buttonInteractionAvailable = false;

                    // Set timer for respawn after 2 more seconds
                    this.respawnTimeout = setTimeout(() => {
                        this.respawn();
                    }, 2000);
                }, 2000);
            }
        }

        // Handle button interactions during the 2-second window
        if (this.buttonInteractionAvailable && currentTime - this.collisionStartTime <= 1000) {
            if (input.keys.KeyB) {
                if (gameInstance.audioManager) {
                    gameInstance.audioManager.playSound('professore_smack');
                }
                if (gameInstance.scoreManager) {
                    gameInstance.scoreManager.increaseScore('love', 2);
                }
                this.buttonInteractionAvailable = false;
            }
            else if (input.keys.KeyF) {
                if (gameInstance.audioManager) {
                    gameInstance.audioManager.playSound('suina_fuck');
                }
                if (gameInstance.scoreManager) {
                    gameInstance.scoreManager.increaseScore('love', 5);
                }
                this.buttonInteractionAvailable = false;
            }
        }
    }

    cleanup() {
        if (this.respawnTimeout) {
            clearTimeout(this.respawnTimeout);
        }
        this.isColliding = false;
        this.collisionStartTime = null;
        this.hasChangedSprite = false;
        this.buttonInteractionAvailable = false;
        this.soundPlayed = false;
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (!this.isVisible) return;

        // Check for collision with player
        if (this.checkCollision(player)) {
            this.handleCollision(player, input);
            return;
        }

        // Reset collision states if not colliding
        if (!this.checkCollision(player) && this.isColliding) {
            this.cleanup();
        }

        const currentTime = performance.now();
        const maxDeltaTime = 32;
        const effectiveDeltaTime = Math.min(deltaTime, maxDeltaTime);

        // Regular movement behavior when not colliding
        if (!this.isColliding) {
            const timeSinceLastChange = currentTime - this.lastDirectionChange;
            
            if (currentTime - this.moveTimer > this.changeDirectionInterval || 
                (this.stuckTimer > 500 && timeSinceLastChange > 1000)) {
                this.randomizeDirection(worldBounds);
                this.moveTimer = currentTime;
                this.lastDirectionChange = currentTime;
                this.stuckTimer = 0;
                this.directionChangeCount = 0;
            }

            const distance = Math.hypot(player.x - this.x, player.y - this.y);

            if (distance < 150) {
                this.runAwayFrom(player, effectiveDeltaTime, worldBounds);
                this.isIdle = false;
            } else {
                const moved = this.moveRandomly(effectiveDeltaTime, worldBounds);
                if (!moved) {
                    this.stuckTimer += deltaTime * 16.67;
                } else {
                    this.stuckTimer = 0;
                }
            }
        }

        // Update animation frame
        if (!this.isIdle && currentTime - this.lastUpdateTime >= this.animationSpeed) {
            this.frame = (this.frame + 1) % this.totalFrames;
            this.lastUpdateTime = currentTime;
        }
    }


    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        const adjustedSpeed = this.speed * deltaTime * 1.2;

        const oldX = this.x;
        const oldY = this.y;

        const randomOffset = Math.random() * 0.2 - 0.1;
        const finalAngle = angle + randomOffset;

        this.x = Math.min(Math.max(this.x + Math.cos(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.width - this.width);
        this.y = Math.min(Math.max(this.y + Math.sin(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.height - this.height);

        if (this.x !== oldX || this.y !== oldY) {
            this.updateDirection(this.x - oldX, this.y - oldY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const oldX = this.x;
        const oldY = this.y;

        switch (this.direction) {
            case 'up':
                this.y = Math.max(this.y - adjustedSpeed, 0);
                break;
            case 'down':
                this.y = Math.min(this.y + adjustedSpeed, worldBounds.height - this.height);
                break;
            case 'left':
                this.x = Math.max(this.x - adjustedSpeed, 0);
                break;
            case 'right':
                this.x = Math.min(this.x + adjustedSpeed, worldBounds.width - this.width);
                break;
        }

        const moved = (Math.abs(this.x - oldX) > 0.01 || Math.abs(this.y - oldY) > 0.01);
        
        if (moved) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
            this.stuckTimer = 0;
        } else {
            this.stuckTimer += deltaTime * 16.67;
        }

        return moved;
    }

    randomizeDirection(worldBounds) {
        const { width, height } = worldBounds;
        const edgeBuffer = 50;
        const cornerBuffer = 100;
        
        const nearLeft = this.x < edgeBuffer;
        const nearRight = this.x > width - this.width - edgeBuffer;
        const nearTop = this.y < edgeBuffer;
        const nearBottom = this.y > height - this.height - edgeBuffer;

        let directions = ['up', 'down', 'left', 'right'];

        if (this.directionChangeCount < 3) {
            if (!nearLeft && !nearRight && !nearTop && !nearBottom) {
                if (Math.random() < 0.7) {
                    return;
                }
            }
        }

        // Filter out directions based on position
        if (nearLeft) directions = directions.filter(d => d !== 'left');
        if (nearRight) directions = directions.filter(d => d !== 'right');
        if (nearTop) directions = directions.filter(d => d !== 'up');
        if (nearBottom) directions = directions.filter(d => d !== 'down');

        // Special handling for corners
        if (this.x < cornerBuffer && this.y < cornerBuffer) {
            directions = ['right', 'down'];
        } else if (this.x > width - cornerBuffer && this.y < cornerBuffer) {
            directions = ['left', 'down'];
        } else if (this.x < cornerBuffer && this.y > height - cornerBuffer) {
            directions = ['right', 'up'];
        } else if (this.x > width - cornerBuffer && this.y > height - cornerBuffer) {
            directions = ['left', 'up'];
        }

        // Ensure we have valid directions
        if (directions.length === 0) {
            directions = ['up', 'down', 'left', 'right'];
        }

        // Avoid choosing the opposite direction of current movement
        const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };
        if (this.direction && this.directionChangeCount < 2) {
            directions = directions.filter(d => d !== opposites[this.direction]);
        }

        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
        this.directionChangeCount++;
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }
}












Suina2.js:
// Suina2.js
import { BaseCharacter } from './BaseCharacter.js';

export class Suina2 extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
    }

    updateBehavior(player, worldBounds, deltaTime) {
        // Currently no special behavior: remains idle
        // If needed, add logic similar to Suina1 or other chars
        this.isIdle = true;
        this.direction = 'down';
    }
}




SuinaEvil.js:
// SuinaEvil.js
import { BaseCharacter } from './BaseCharacter.js';

export class SuinaEvil extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
    }

    updateBehavior(player, worldBounds, deltaTime) {
        // Placeholder: remains idle
        this.isIdle = true;
        this.direction = 'down';
    }
}





Diego.js:
// Diego.js
import { BaseCharacter } from './BaseCharacter.js';

export class Diego extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
    }

    updateBehavior(player, worldBounds, deltaTime) {
        // Placeholder: remains idle
        this.isIdle = true;
        this.direction = 'down';
    }
}





Milly.js:
// Milly.js
import { BaseCharacter } from './BaseCharacter.js';

export class Milly extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
    }

    updateBehavior(player, worldBounds, deltaTime) {
        // Placeholder: remains idle
        this.isIdle = true;
        this.direction = 'down';
    }
}





Walter.js:
// Walter.js
import { BaseCharacter } from './BaseCharacter.js';

export class Walter extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
    }

    updateBehavior(player, worldBounds, deltaTime) {
        // Placeholder: remains idle
        this.isIdle = true;
        this.direction = 'down';
    }
}







