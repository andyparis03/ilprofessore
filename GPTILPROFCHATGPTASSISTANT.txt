"Il Professore," players is a professor on a unique mission through the city streets. The professor must collect "love points" by interacting with various Swines (pig-like creatures) that roam the urban landscape. Each interaction can either be a kiss (B button) or a more passionate approach (F button), earning different amounts of love points.
The player can access different city areas: the Teatro, Malafama, Gusto, and Chester. In Teatro and Malafama (disco clubs), the professor encounters different types of Swines - some friendly, others mischievous. The Evil Swine is particularly dangerous; interacting wrongly with it leads to game over.

Walter, the owner in Restaurant Gusto , helps restore the professor's energy by offering pizza when caught. However, Gusto is only accessible when energy is low (below 30 points). 

Chester Cocktail bar hosts Diego, who drains energy but increases friendship points. Chester becomes available only when friendship levels are critical (below 30 points).
Managing three vital stats is crucial:

Energy: Decreases over time, replenished by Walter's pizza
Love: Increases through Suine interactions
Friendship: Constantly decreases unless maintained through Diego interactions

The goal is to reach 100 love points while balancing energy and friendship. Success requires strategic timing of visits to Walter for energy boosts and Diego for friendship maintenance, all while carefully choosing which Swines to interact with and how.
The game ends either in victory (100 love points) or defeat through various means: running out of energy, letting friendship drop to zero, or encountering the Evil Swine with the wrong approach.

--------


Il Professore - Instructions
Il Professore e l’Amore: Aiuta il Professore a raggiungere l’obiettivo finale: accumulare 100 punti amore per vincere il gioco! Ogni interazione di successo aumenta il punteggio amore (+10 punti).
Il Professore e i Nemici:
Suina Mala: Evitala a tutti i costi o perderai energia (-10 punti energia).
Walter e Diego: Sono amici preziosi! Interagisci con loro per ottenere vantaggi (energia o amore).
Il Professore e le Risorse:
Energia: Si consuma costantemente. Puoi ricaricarla mangiando pizza (+20 energia).
Amicizia: Non abbandonare Diego! Perderai punti amicizia se non lo aiuti (-10 amicizia al minuto).
Il Professore e le Azioni:
Bacio: Usa il tasto "B" per aumentare i punti amore (+10 punti).
Fuck: Usa il tasto "F" per affrontare nemici difficili o evitare penalità.
Vittoria: Raggiungi 100 punti amore e il Professore sarà trionfante nel suo viaggio romantico!
Buona fortuna, Professore!



>>>>>tell me if you find bugs or discrepancies or inconsistency <<<<<<

//////////////////////////////////////
IMPORTANT notice to you Calude coding assistant: recently I noted, as the code get bigger and complex, that you are loosing your ability to focus on the original code and do not stick with the original project. For example sometimes you are creating new methods and variables that are not connected with the other modules and this makes the game malfunction. Do not change name to existing methods that works fine! Please stick with the original plan and code, always doublecheck that everything is consistent. No need to create new methods or new logics if the actual ones are already working fine. Always doublecheck if the method (or similar methods) that you are creating or improving are already exsisting and working fine. Stick to the plan, don't go off track of the existing code, be consistent, cosider the project as a whole, when coding a change or modification always check the integrity and consistency between all modules!
Remember to: Keep all existing functionality intact,
Use consistent naming conventions with current code,
Maintain compatibility with all modules,
Not duplicate any existing methods,
Preserve the current event handling patterns.
///////////////////////////////////


Coding a videogame in javascript, html5 and css: find below in text the tree structure (TREEilprofessore) and I attached to this chat all the modules that compose a videogame called "IL PROFESSORE" is an action adventure with elements of top-down puzzle platformer. "Il Professore" is the protagonist of the game. "Il Professore" Is a Player Character in the style of Mario bros. 
Consider that the createCharacter method is designed to allow for progressive activation of characters. As new functionality are implemented for more characters, their types will be added to the activeCharacters.

Please only answer with effective solutions assuming that all the assests are in place in the right directories. There is no need to verify that the code is correctly defined as the code I gave to you is at is it. 
Only focus on the code logic and find the cause that is generating the error then give the solutions, always use the assumptions below:
 
Claude, you are a javascripit master helping me coding and you always follow the rules:
1. Assume All Provided Code is Correct and Present
You will focus solely on logical flow and interactions between the code components without redundantly suggesting corrections to lines or assets I have already confirmed.

2. Focus on Logical Causes Only
You will analyze the problem based on the symptoms (like your error logs or outputs) and provide targeted suggestions for the root cause without assuming missing assets or functionality.

3. Skip Verifications Unless I Request Them
You will avoid generic debugging suggestions (like verifying asset directories or sprite mappings) unless the issue specifically points to those.

4. Consolidate Steps into Clear, Minimal Actions
You'll ensure my responses are precise, avoiding redundant or unnecessary steps, and focus on changes or analysis directly tied to the problem.

5. Every time you write a code for me you rewrite the complete module with the fixes and the updated modifications. Always remember to put on the top of the code as a label the name of the original Module (ie LevelManager.js or main.js or AssetLoader.js etc.)

6. If you're unsure about something, it's okay to admit it. Just say you don’t know.

Don't do anything, just analyze all the files, understand the game and its structure and wait for my next request, answer OK




TREEilprofessore:
Ilprofessore
│   config.js
│   index.html
│   main.js
│
├───assets
│   ├───maps
│   │       level1.json
│   │
│   ├───sounds
│   │       recharge.mp3
│   │       diego-sound.mp3
│   │       drink.mp3
│   │       dingdong.mp3
│   │       milly-sound.mp3
│   │       prof-fuck.mp3
│   │       prof-punch.mp3
│   │       prof-smack.mp3
│   │       buzz.mp3
│   │       prof-step.mp3
│   │       prof-theme.mp3
│   │       suina-evil.mp3
│   │       suina-fuck.mp3
│   │       suina-sound.mp3
│   │       suina-walk.mp3
│   │       urlo.mp3
│   │       walter-sound.mp3
│   │       walter-welcome.mp3
│   │       win.mp3
│   │       buzz.mp3
│   │
│   └───sprites
│       │   background.png
│       │   background2.png
│       │   background3.png
│       │   background4.png
│       │   background5.png
│       │   fallback-background.png
│       │   fallback-idle.png
│       │   fallback-spritesheet.png
│       │   jail.png
│       │   professore-idle.png
│       │   professore-spritesheet.png
│       │   skull.png
│       │   skull1.png
│       │   splash.png
│       │   instructions.png
│       │   winscreen.png
│       │
│       ├───diego
│       │       diego-attack.png
│       │       diego-idle.png
│       │       diego-spritesheet.png
│       │
│       ├───milly
│       │       milly-idle.png
│       │       milly-interact.png
│       │       milly-spritesheet.png
│       │
│       ├───professore
│       │       professore-idle.png
│       │       professore-spritesheet.png
│       │   	professore-punchR.png
│       │   	professore-punchL.png
│       │
│       ├───suina1
│       │       suina1-attack.png
│       │       suina1-idle.png
│       │       suina1-spritesheet.png
│       │       suina1RED-spritesheet.png
│       │
│       ├───suina2
│       │       suina2-attack.png
│       │       suina2-idle.png
│       │       suina2-spritesheet.png
│       │       suina2BLUE-spritesheet.png
│       │
│       ├───suinaEvil
│       │       suinaevil-attack.png
│       │       suinaevil-idle.png
│       │       suinaevil-spritesheet.png
│       │       suinaevil-punch.png
│       │
│       └───walter
│               walter-attack.png
│               walter-idle.png
│               walter-spritesheet.png
│
├───characters
│       BaseCharacter.js
│       Diego.js
│       Milly.js
│       Player.js
│       Suina1.js
│       Suina2.js
│       SuinaEvil.js
│       Walter.js
│
├───js
│   └───engine
│	    JoystickController.js
│           AudioManager.js
│           Camera.js
│           GameStateManager.js
│           Input.js
│           Renderer.js
│           ScoreAnimation.js
│           ScoreManager.js
│
├───levels
│       LevelManager.js
│
├───styles
│       style.css
│
└───utils
        AssetLoader.js
        CharacterRegistry.js




------------------



main.js:
// main.js
import { CONFIG } from './config.js';
import { Camera } from './js/engine/Camera.js';
import { InputHandler } from './js/engine/Input.js';
import { Player } from './characters/Player.js';
import { Renderer } from './js/engine/Renderer.js';
import { AssetLoader } from './utils/AssetLoader.js';
import { AudioManager } from './js/engine/AudioManager.js';
import { LevelManager } from './levels/LevelManager.js';
import { ScoreManager } from './js/engine/ScoreManager.js';
import { GameStateManager } from './js/engine/GameStateManager.js';

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Core systems initialization with verified state
        this.initializationState = {
            assets: false,
            player: false,
            levelManager: false,
            renderer: false
        };

        // Core components (initially null)
        this.camera = null;
        this.input = null;
        this.audioManager = new AudioManager(); // Create but don't init
        this.scoreManager = null;
        this.gameState = null;
        this.renderer = null;
        this.levelManager = null;
        this.player = null;
        
        // Make game instance globally available immediately
        window.gameInstance = this;
        
        // Initialize core systems
        this.setupCoreSystems();
        
        // State tracking
        this.initialized = false;
        this.assetsLoaded = false;
        
        // Performance monitoring
        this.lastUpdateTime = performance.now();
        this.frameCount = 0;
        this.fps = 0;
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = performance.now();
    }

    setupCoreSystems() {
        // Initialize core components
        this.camera = new Camera(CONFIG.CANVAS.DEFAULT_WIDTH, CONFIG.CANVAS.DEFAULT_HEIGHT);
        this.input = new InputHandler();
        this.scoreManager = new ScoreManager(this.ctx);
        this.gameState = new GameStateManager(this);

        // Set up canvas and event listeners
        this.setupCanvas();
        window.addEventListener('resize', () => this.setupCanvas());
    }

    setupCanvas() {
        const isMobile = window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT;
        
        if (isMobile) {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
        } else {
            this.canvas.width = CONFIG.CANVAS.DEFAULT_WIDTH;
            this.canvas.height = CONFIG.CANVAS.DEFAULT_HEIGHT;
            this.canvas.style.width = `${CONFIG.CANVAS.DEFAULT_WIDTH}px`;
            this.canvas.style.height = `${CONFIG.CANVAS.DEFAULT_HEIGHT}px`;
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = '50%';
            this.canvas.style.left = '50%';
            this.canvas.style.transform = 'translate(-50%, -50%)';
        }
        
        if (this.camera) {
            this.camera.width = this.canvas.width;
            this.camera.height = this.canvas.height;
        }
    }

    async loadGameAssets() {
        try {
            console.log('Loading game assets...');
            const assets = await AssetLoader.loadAssets();
            this.assets = assets;
            this.assetsLoaded = true;
            this.initializationState.assets = true;
            console.log('Game assets loaded successfully');
            return assets;
        } catch (error) {
            console.error('Asset loading failed:', error);
            this.initializationState.assets = false;
            throw new Error('Asset loading failed');
        }
    }

    async init() {
        if (this.initialized) {
            console.warn('Game already initialized');
            return;
        }

        try {
            console.log('Starting game initialization sequence...');
            
            // Step 1: Load game assets
            const assets = await this.loadGameAssets();
            
            // Step 2: Initialize player
            this.player = new Player(
                CONFIG.WORLD.WIDTH / 2,
                CONFIG.WORLD.HEIGHT / 2,
                CONFIG.PLAYER.WIDTH,
                CONFIG.PLAYER.HEIGHT,
                assets.sprites.professore,
                'professore'
            );
            this.initializationState.player = true;

            // Step 3: Initialize game systems
            console.log('Initializing game systems...');
            this.levelManager = new LevelManager(assets, this.gameState);
            this.initializationState.levelManager = true;

            this.renderer = new Renderer(this.ctx, this.levelManager, this.gameState);
            this.initializationState.renderer = true;
            
            // Store renderer reference in gameState
            this.gameState.renderer = this.renderer;

            // Step 4: Load initial level
            console.log('Loading initial level...');
            await this.levelManager.loadLevel(1, this.player);

            // Verify all systems
            if (this.verifyInitialization()) {
                this.initialized = true;
                console.log('Game initialization complete');
                this.startGameLoop();
            } else {
                throw new Error('System verification failed');
            }

        } catch (error) {
            console.error('Game initialization failed:', error);
            this.handleInitializationError(error);
            throw error;
        }
    }

    verifyInitialization() {
        const failed = Object.entries(this.initializationState)
            .filter(([, value]) => !value)
            .map(([key]) => key);

        if (failed.length > 0) {
            console.error('Initialization failed for:', failed);
            return false;
        }

        return true;
    }

    handleInitializationError(error) {
        // Display error message to user
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'white';
        this.ctx.font = '20px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('Failed to start game. Please refresh the page.', 
            this.canvas.width / 2, this.canvas.height / 2);
    }

    startGameLoop() {
        console.log('Starting game loop');
        this.lastUpdateTime = performance.now();
        this.gameLoop();
    }

    update() {
        if (!this.initialized || this.gameState.isGameOver) return;

        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastUpdateTime) / 16.67;
        this.lastUpdateTime = currentTime;

        // Update player
        this.player.update(this.input, {
            width: CONFIG.WORLD.WIDTH,
            height: CONFIG.WORLD.HEIGHT
        });

        // Update level and characters
        this.levelManager.update(
            this.player,
            {
                width: CONFIG.WORLD.WIDTH,
                height: CONFIG.WORLD.HEIGHT
            },
            this.input
        );

        // Check level transitions
        if (this.levelManager.checkLevelTransition(this.player)) {
            console.log(`Transitioned to Level ${this.levelManager.currentLevel}`);
        }

        // Update camera and audio
        this.camera.follow(this.player, CONFIG.WORLD.WIDTH, CONFIG.WORLD.HEIGHT);
        if (this.audioManager.initialized) {
            this.audioManager.handleFootsteps(this.player, !this.player.isIdle);
        }
    }

    draw() {
        if (!this.initialized) return;
        
        // Use consolidated rendering approach
        this.renderer.draw(this.player, this.assets.sprites, this.camera);
        
        // Draw score
        this.scoreManager.draw();

        // Update and draw FPS if in debug mode
        if (CONFIG.DEBUG) {
            this.updateFPS();
            this.drawFPS();
        }
    }

    updateFPS() {
        const now = performance.now();
        this.frameCount++;

        if (now - this.lastFpsUpdate >= this.fpsUpdateInterval) {
            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
            this.frameCount = 0;
            this.lastFpsUpdate = now;
        }
    }

    drawFPS() {
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px Arial';
        this.ctx.fillText(`FPS: ${this.fps}`, 10, 20);
    }

    gameLoop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
}

// Game startup
const startGame = async () => {
    try {
        console.log('Creating game instance...');
        const game = new Game();
        await game.init();
        console.log('Game started successfully');
    } catch (error) {
        console.error('Failed to start game:', error);
    }
};

startGame();














<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FH638KSG7B"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FH638KSG7B');
</script>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1, viewport-fit=cover">
  <title>Il Professore Game</title>
  <link rel="stylesheet" href="./styles/style.css">
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

<button id="back-button" type="button">
    <img src="./assets/sprites/exit.png" alt="Exit">
</button>
  
  <div id="mobile-controls">
    <div id="action-container">
      <button type="button" id="bacio" class="action-btn">B</button>
      <button type="button" id="fuck" class="action-btn">F</button>
    </div>
  </div>

  <script src="./main.js" type="module"></script>
</body>
</html>










config.sys:
// config.js
export const CONFIG = {
    CANVAS: {
        DEFAULT_WIDTH: 800,
        DEFAULT_HEIGHT: 600,
        MOBILE_BREAKPOINT: 768
    },
    WORLD: {
        WIDTH: 800,
        HEIGHT: 600
    },
    PLAYER: {
        WIDTH: 68,
        HEIGHT: 68,
        SPEED: 1,
        TOTAL_FRAMES: 4,
        FRAME_DELAY: 4,
        SPEED_MULTIPLIERS: {
            DESKTOP: 1.0,
            MOBILE: 2.0,
            TABLET: 0.85
        }
    },
    AUDIO: {
        MUSIC_VOLUME: 0.1,
        SFX_VOLUME: 0.3,
        FOOTSTEP_INTERVAL: 300
    },
    LEVELS: {
        1: {
            name: 'StartingLevel',
            backgroundKey: 'background1',
            transitions: {
                TEATRO: { x: { min: 0, max: 150 }, y: { min: 0, max: 100 }, nextLevel: 2 },
                MALAFAMA: { x: { min: 550, max: 800 }, y: { min: 0, max: 100 }, nextLevel: 3 },
                GUSTO: { x: { min: 0, max: 150 }, y: { min: 400, max: 600 }, nextLevel: 4 },
                CHESTER: { x: { min: 600, max: 800 }, y: { min: 450, max: 600 }, nextLevel: 5 }
            }
        },
        2: { name: 'Teatro', backgroundKey: 'background2' },
        3: { name: 'Malafama', backgroundKey: 'background3' },
        4: { name: 'Gusto', backgroundKey: 'background4' },
        5: { name: 'Chester', backgroundKey: 'background5' }
    }
};















assetLoader.js:
// AssetLoader.js
export class AssetLoader {
    constructor() {
        // Empty constructor as we're using static methods
    }

    static async loadImage(src, fallbackSrc = null) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => {
                if (fallbackSrc) {
                    console.warn(`Failed to load ${src}, trying fallback: ${fallbackSrc}`);
                    img.src = fallbackSrc;
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load fallback image: ${fallbackSrc}`));
                } else {
                    reject(new Error(`Failed to load image: ${src}`));
                }
            };
            img.src = src;
        });
    }

    static async loadSound(audioContext, url) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            return await audioContext.decodeAudioData(arrayBuffer);
        } catch (error) {
            console.error(`Failed to load sound: ${url}`, error);
            throw new Error(`Failed to load sound: ${url}`);
        }
    }

    static async loadAssets() {
        try {
            console.log('Starting asset loading...');
            const audioContext = new (window.AudioContext || window.webkitAudioContext)(); 
            
            console.log('Loading assets...');
            const [
                splashScreen,
                winScreen,
                instructionsScreen,
                professoreidle,
                professorewalking,
                skullSprite,
                millyidle,
                millyspritesheet,
                millyinteract,
                suina1idle,
                suina1walking,
                suina1attack,
                suina2idle,
                suina2walking,
                suina2attack,
                suinaevilidle,
                suinaevilwalking,
                suinaevilattack,
                walteridle,
                walterwalking,
                walterattack,
                diegoidle,
                diegowalking,
                diegoattack,
                background1,
                background2,
                background3,
                background4,
                background5,
                proffuck,
                profpunch,
                profsmack,
                buzz,
                dingdong,
                drink,
                profstep,
                proftheme,
                suinafuck,
                suinasound,
                suinaevil,
                suinawalk,
                waltersound,
                walterwelcome,
                diegosound,
                millysound,
                recharge,
                win
            ] = await Promise.all([
                AssetLoader.loadImage('./assets/sprites/splash.png'),
                AssetLoader.loadImage('./assets/sprites/winscreen.png'),
                AssetLoader.loadImage('./assets/sprites/instructions.png'),
                AssetLoader.loadImage('./assets/sprites/professore/professore-idle.png'),
                AssetLoader.loadImage('./assets/sprites/professore/professore-spritesheet.png'),
                AssetLoader.loadImage('./assets/sprites/skull.png'),
                AssetLoader.loadImage('./assets/sprites/milly/milly-idle.png'),
                AssetLoader.loadImage('./assets/sprites/milly/milly-spritesheet.png'),
                AssetLoader.loadImage('./assets/sprites/milly/milly-interact.png'),
                AssetLoader.loadImage('./assets/sprites/suina1/suina1-idle.png'),
                AssetLoader.loadImage('./assets/sprites/suina1/suina1-spritesheet.png'),
                AssetLoader.loadImage('./assets/sprites/suina1/suina1-attack.png'),
                AssetLoader.loadImage('./assets/sprites/suina2/suina2-idle.png'),
                AssetLoader.loadImage('./assets/sprites/suina2/suina2-spritesheet.png'),
                AssetLoader.loadImage('./assets/sprites/suina2/suina2-attack.png'),
                AssetLoader.loadImage('./assets/sprites/suinaEvil/suinaevil-idle.png'),
                AssetLoader.loadImage('./assets/sprites/suinaEvil/suinaevil-spritesheet.png'),
                AssetLoader.loadImage('./assets/sprites/suinaEvil/suinaevil-attack.png'),
                AssetLoader.loadImage('./assets/sprites/walter/walter-idle.png'),
                AssetLoader.loadImage('./assets/sprites/walter/walter-spritesheet.png'),
                AssetLoader.loadImage('./assets/sprites/walter/walter-attack.png'),
                AssetLoader.loadImage('./assets/sprites/diego/diego-idle.png'),
                AssetLoader.loadImage('./assets/sprites/diego/diego-spritesheet.png'),
                AssetLoader.loadImage('./assets/sprites/diego/diego-attack.png'),
                AssetLoader.loadImage('./assets/sprites/background.png'),
                AssetLoader.loadImage('./assets/sprites/background2.png'),
                AssetLoader.loadImage('./assets/sprites/background3.png'),
                AssetLoader.loadImage('./assets/sprites/background4.png'),
                AssetLoader.loadImage('./assets/sprites/background5.png'),
                AssetLoader.loadSound(audioContext, './assets/sounds/prof-fuck.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/prof-punch.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/prof-smack.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/buzz.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/dingdong.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/drink.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/prof-step.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/prof-theme.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/suina-fuck.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/suina-sound.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/suina-evil.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/suina-walk.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/walter-sound.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/walter-welcome.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/diego-sound.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/milly-sound.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/recharge.mp3'),
                AssetLoader.loadSound(audioContext, './assets/sounds/win.mp3')
            ]);

            console.log('All assets loaded successfully');

            return {
                sprites: {
                    professore: { idle: professoreidle, walking: professorewalking, freeze: skullSprite },
                    milly: { idle: millyidle, spritesheet: millyspritesheet, interact: millyinteract },
                    suina1: { idle: suina1idle, walking: suina1walking, attack: suina1attack },
                    suina2: { idle: suina2idle, walking: suina2walking, attack: suina1attack },
                    suinaevil: { idle: suinaevilidle, walking: suinaevilwalking, attack: suina1attack },
                    walter: { idle: walteridle, walking: walterwalking, attack: walterattack },
                    diego: { idle: diegoidle, walking: diegowalking, attack: diegoattack },
                    splash: splashScreen,
                    instructions: instructionsScreen,
                    winscreen: winScreen
                },
                backgrounds: {
                    background1,
                    background2,
                    background3,
                    background4,
                    background5
                },
                sounds: {
                    proffuck,
                    profpunch,
                    profsmack,
                    buzz,
                    dingdong,
                    drink,
                    profstep,
                    proftheme,
                    suinafuck,
                    suinasound,
                    suinaevil,
                    suinawalk,
                    waltersound,
                    walterwelcome,
                    diegosound,
                    millysound,
                    recharge,
                    win
                },
                audioContext
            };
        } catch (error) {
            console.error('Error loading assets:', error);
            throw new Error('Failed to load assets.');
        }
    }
}












CharacterRegistry.js:
// CharacterRegistry.js
export class CharacterRegistry {
    constructor() {
        this.characterClasses = new Map();
        this.characterStates = new Map();
    }

    registerCharacter(type, characterClass, stateDefinition) {
        this.characterClasses.set(type.toLowerCase(), {
            class: characterClass,
            defaultState: stateDefinition
        });
    }

    getCharacterClass(type) {
        return this.characterClasses.get(type.toLowerCase())?.class;
    }

    getDefaultState(type) {
        return this.characterClasses.get(type.toLowerCase())?.defaultState;
    }

    preserveState(character) {
        if (!character || !character.type) return null;

        const defaultState = this.getDefaultState(character.type);
        if (!defaultState) return null;

        // Create state object based on character's default state definition
        const state = {};
        for (const [key, definition] of Object.entries(defaultState)) {
            if (typeof definition === 'function') {
                state[key] = definition(character);
            } else {
                state[key] = character[key] ?? definition;
            }
        }

        return state;
    }
}














style.css:
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  overflow: hidden;
  height: 100%;
  width: 100%;
  position: fixed;
  touch-action: none;
  overscroll-behavior: none;
}

canvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: block;
  background-color: #f0f0f0;
}

#back-button {
  position: fixed;
  top: 500px;
  left: 800px;
  padding: 10px 20px;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 5px;
  font-size: 16px;
  cursor: pointer;
  z-index: 1000;
  display: none;
    background-color: transparent;
    border: none;
}

#back-button img {
    width: auto;
    height: auto;
}

#back-button:hover {
  background-color: rgba(0, 0, 0, 0.7);
}

/* Mobile Controls */
#mobile-controls {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 40vh;
  pointer-events: none;
  z-index: 1000;
}

#action-container {
  display: none; 
  position: absolute;
  right: 15px;
  bottom: 10px;
  gap: 15px;
  pointer-events: auto;
}

.action-btn {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background: rgba(76, 175, 80, 0.8);
  border: none;
  color: white;
  font-size: 24px;
  font-weight: bold;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  pointer-events: auto;
}

.action-btn:active,
.action-btn.active {
  transform: scale(0.9);
  background: rgba(56, 142, 60, 0.9);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* Joystick Styles */
#joystick-zone {
  position: relative;
}

.joystick-boundary {
  position: absolute;
  width: 160px;
  height: 160px;
  border: 2px dashed rgba(255, 255, 255, 0.4);
  border-radius: 50%;
  pointer-events: none;
  left: 5px;
  bottom: 5px;
}

.joystick-base {
  position: absolute;
  width: 120px;
  height: 120px;
  background: rgba(255, 255, 255, 0.2);
  border: 2px solid rgba(255, 255, 255, 0.4);
  border-radius: 50%;
  pointer-events: auto;
  touch-action: none;
}

.joystick-knob {
  position: absolute;
  width: 50px;
  height: 50px;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 50%;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}

@media (max-width: 768px) {
  canvas {
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0;
    left: 0;
    transform: none;
  }

  #back-button {
        bottom: 100px;  
        right: 0px;    
        left: auto;    
        top: auto;      
        padding: 8px 16px;
        font-size: 14px;

 

  }

  #mobile-controls {
    display: block;
  }
}

@media (min-width: 769px) {
  #mobile-controls {
    display: none;
  }
}












LevelManager.js:
// LevelManager.js
import { CONFIG } from '../config.js';
import { CharacterRegistry } from '../utils/CharacterRegistry.js';
import { Suina1 } from '../characters/Suina1.js';
import { Suina2 } from '../characters/Suina2.js';
import { SuinaEvil } from '../characters/SuinaEvil.js';
import { Walter } from '../characters/Walter.js';
import { Diego } from '../characters/Diego.js';
import { Milly } from '../characters/Milly.js';

export class LevelManager {
    constructor(assets, gameState = null) {
        this.assets = assets;
        this.gameState = gameState;
        this.registry = new CharacterRegistry();
        this.currentLevel = 1;
        this.characters = [];
        this.characterTimers = {};
        this.friendshipInterval = null;
        this.player = null;
        this.preservedScores = null;
        this.transitionState = {
            inProgress: false,
            timeout: null,
            startTime: null,
            duration: 500,
            previousLevel: null,
            targetLevel: null
        };

        this.registerCharacters();
        this.setupBackButton();

        console.log('LevelManager Constructor:', {
            worldBounds: {
                width: CONFIG.WORLD.WIDTH,
                height: CONFIG.WORLD.HEIGHT
            }
        });
    }

    isGameStopped() {
        return this.transitionState.inProgress || (this.gameState?.isGameOver ?? false);
    }

    registerCharacters() {
        this.registry.registerCharacter('suina1', Suina1);
        this.registry.registerCharacter('suina2', Suina2);
        this.registry.registerCharacter('suinaevil', SuinaEvil);
        this.registry.registerCharacter('walter', Walter);
        this.registry.registerCharacter('diego', Diego);
        this.registry.registerCharacter('milly', Milly);
    }

    setupBackButton() {
        const backButton = document.getElementById('back-button');
        if (!backButton) return;

        backButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (this.currentLevel !== 1) {
                this.transitionToLevel1();
            }
        });

        this.updateBackButtonVisibility();
    }

    updateBackButtonVisibility() {
        const backButton = document.getElementById('back-button');
        if (backButton) {
            backButton.style.display = this.currentLevel === 1 ? 'none' : 'block';
        }
    }

    async transitionToLevel1() {
        if (this.isGameStopped()) return;
        
        this.clearTimers();
        
        if (this.player) {
            this.player.x = CONFIG.WORLD.WIDTH / 2;
            this.player.y = CONFIG.WORLD.HEIGHT / 2;
        }

        await this.loadLevel(1, this.player);
        this.updateBackButtonVisibility();
    }

    async loadLevel(levelNumber, player) {
        const levelConfig = CONFIG.LEVELS[levelNumber];
        if (!levelConfig) {
            console.error(`Level ${levelNumber} configuration not found.`);
            return;
        }

        if (this.isGameStopped()) {
            console.warn('Level transition blocked - transition in progress or game over');
            return;
        }

        // Handle friendship system when leaving level 5
// In loadLevel method
if (levelNumber !== 5) {
    const wasInLevel5 = (this.currentLevel === 5);
    if (this.friendshipInterval) {
        clearInterval(this.friendshipInterval);
        this.friendshipInterval = null;
    }
    if (wasInLevel5 && gameInstance?.scoreManager) {
        gameInstance.scoreManager.startFriendshipCountdown();
    }
}

        console.log('Loading level:', {
            level: levelNumber,
            worldBounds: {
                width: CONFIG.WORLD.WIDTH,
                height: CONFIG.WORLD.HEIGHT
            }
        });

        try {
            await this.startTransition(levelNumber);
            const storedStates = this.preserveCharacterStates();
            await this.clearCurrentLevel();
            await this.setupNewLevel(levelNumber, player, storedStates);
            await this.completeTransition();
            console.log(`Loaded level ${levelNumber}`);
        } catch (error) {
            console.error('Error during level transition:', error);
            this.handleTransitionError();
        }
    }

    async startTransition(newLevelNumber) {
        console.log('Starting level transition:', newLevelNumber);
        const gameInstance = window.gameInstance;
        if (gameInstance?.scoreManager) {
            gameInstance.scoreManager.setTransitionState(true);
        }

        this.transitionState = {
            inProgress: true,
            startTime: performance.now(),
            previousLevel: this.currentLevel,
            targetLevel: newLevelNumber,
            duration: 500,
            timeout: null
        };

        if (this.transitionState.timeout) {
            clearTimeout(this.transitionState.timeout);
        }

        if (gameInstance?.scoreManager) {
            this.preservedScores = { ...gameInstance.scoreManager.scores };
        }

        this.characters.forEach(char => {
            if (char && typeof char.pauseUpdates === 'function') {
                char.pauseUpdates();
            }
        });
    }

    preserveCharacterStates() {
        const storedStates = new Map();
        this.characters.forEach(char => {
            if (char && char.type) {
                const state = this.registry.preserveState(char);
                if (state) {
                    storedStates.set(char.type, state);
                }
            }
        });
        return storedStates;
    }

    async clearCurrentLevel() {
        this.clearTimers();
        
        this.characters.forEach(char => {
            if (char && typeof char.cleanup === 'function') {
                char.cleanup();
            }
        });

        this.characters = [];
        this.characterTimers = {};
    }

    async setupNewLevel(levelNumber, player, storedStates) {
        this.currentLevel = levelNumber;
        
        if (this.player !== player) {
            this.player = player;
        }

        const gameInstance = window.gameInstance;
        if (gameInstance?.scoreManager && this.preservedScores) {
            console.log('Restoring scores:', this.preservedScores);
            gameInstance.scoreManager.scores = { ...this.preservedScores };
            this.preservedScores = null;
        }

        await this.loadCharactersForLevel(levelNumber, storedStates);
        this.updateBackButtonVisibility();
        this.resetPlayerState();

        this.characters.forEach(char => {
            if (char && char.resumeUpdates) {
                char.resumeUpdates();
            }
        });

        console.log('Level setup complete, characters:', this.characters.map(char => ({
            type: char.type,
            isPaused: char.isPaused,
            isIdle: char.isIdle
        })));
    }

    resetPlayerState() {
        if (!this.player) return;

        const now = performance.now();
        this.player.lastUpdateTime = now;
        this.player.lastAnimationUpdate = now;
        this.player.frameTime = now;
        this.player.updateSpeedMultiplier();
        
        this.player.velocity = { x: 0, y: 0 };
        this.player.movementBuffer = { x: 0, y: 0 };

        if (!this.isGameStopped()) {
            this.player.x = CONFIG.WORLD.WIDTH / 2;
            this.player.y = CONFIG.WORLD.HEIGHT / 2;
        }

        this.player.frame = this.player.frame % this.player.totalFrames;
    }

    async completeTransition() {
        return new Promise((resolve) => {
            const remainingTime = Math.max(0, 
                this.transitionState.duration - (performance.now() - this.transitionState.startTime));

            this.transitionState.timeout = setTimeout(() => {
                this.characters.forEach(char => {
                    if (char && char.resumeUpdates) {
                        console.log('Resuming character:', char.type);
                        char.resumeUpdates();
                    }
                });

                const gameInstance = window.gameInstance;
                if (gameInstance?.scoreManager) {
                    setTimeout(() => {
                        gameInstance.scoreManager.setTransitionState(false);
                    }, 100);
                }

                this.transitionState = {
                    inProgress: false,
                    timeout: null,
                    startTime: null,
                    previousLevel: null,
                    targetLevel: null,
                    duration: 500
                };

                resolve();
            }, remainingTime);
        });
    }

    handleTransitionError() {
        const gameInstance = window.gameInstance;
        if (gameInstance?.scoreManager) {
            gameInstance.scoreManager.setTransitionState(false);
        }

        this.transitionState = {
            inProgress: false,
            timeout: null,
            startTime: null,
            previousLevel: null,
            targetLevel: null,
            duration: 500
        };

        if (!this.isGameStopped()) {
            this.characters.forEach(char => {
                if (char && typeof char.resumeUpdates === 'function') {
                    char.resumeUpdates();
                }
            });
        }
    }


pauseFriendshipCountdown() {
    console.log('Pausing friendship increase');
    if (this.friendshipInterval) {
        clearInterval(this.friendshipInterval);
        this.friendshipInterval = null;
    }
}

resumeFriendshipCountdown() {
    console.log('Resuming friendship increase');
    // Only resume if we're in level 5
    if (this.currentLevel === 5) {
        this.startFriendshipIncrease();
    }
}


    startFriendshipIncrease() {
        if (this.friendshipInterval) {
            clearInterval(this.friendshipInterval);
        }

        const gameInstance = window.gameInstance;
        // Stop the countdown first
        if (gameInstance?.scoreManager) {
            if (gameInstance.scoreManager.countdownInterval) {
                clearInterval(gameInstance.scoreManager.countdownInterval);
                gameInstance.scoreManager.countdownInterval = null;
            }
        }

        this.friendshipInterval = setInterval(() => {
            if (gameInstance?.scoreManager && !gameInstance.gameState?.isGameOver) {
                gameInstance.scoreManager.increaseScore('friendship', 3);
            }
        }, 1000);
    }

    loadCharactersForLevel(levelNumber, storedStates) {
        switch (levelNumber) {
            case 1:
                this.addRandomCharacter('milly', 10000);
                break;
            case 2:
            case 3:
                if (this.characters.length === 0) {
                    this.addCharacter('suina1', 
                        Math.random() * (CONFIG.WORLD.WIDTH - CONFIG.PLAYER.WIDTH), 
                        Math.random() * (CONFIG.WORLD.HEIGHT - CONFIG.PLAYER.HEIGHT), 
                        storedStates);
                }
                break;
            case 4:
                const gameInstance = window.gameInstance;
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('walter_welcome');
                }
                this.addCharacter('walter', 150, 250);
                break;
            case 5:
                const game = window.gameInstance;
                if (game?.audioManager) {
                    game.audioManager.playSound('diego_sound');
                }
                
                this.addCharacter('diego', 700, 400);
                this.startFriendshipIncrease();
                break;
            default:
                console.warn(`No characters defined for level ${levelNumber}`);
                break;
        }
    }

    spawnNextRandomCharacter() {
        console.log("Spawning next random character...");
        if (this.currentLevel !== 2 && this.currentLevel !== 3) {
            console.log("Not in level 2 or 3, skipping spawn");
            return;
        }

        const characterTypes = ['suina1', 'suina2', 'suinaevil'];
        const characterType = characterTypes[Math.floor(Math.random() * characterTypes.length)];
        
        console.log(`Selected character type: ${characterType}`);
        
        const x = Math.random() * (CONFIG.WORLD.WIDTH - CONFIG.PLAYER.WIDTH);
        const y = Math.random() * (CONFIG.WORLD.HEIGHT - CONFIG.PLAYER.HEIGHT);
        
        this.addCharacter(characterType, x, y);
    }

    handleCharacterDisappear(character) {
        console.log(`Handling disappearance of character: ${character.type}`);
        
        this.characters = this.characters.filter(c => c !== character);

        if ((character.type === 'suina1' || character.type === 'suina2' || character.type === 'suinaevil') && 
            (this.currentLevel === 2 || this.currentLevel === 3)) {
            console.log("Triggering next random character spawn");
            this.spawnNextRandomCharacter();
        }
    }

    addCharacter(type, x, y, storedStates = null) {
        console.log('Adding character:', { type, x, y });
        const CharacterClass = this.registry.getCharacterClass(type);
        const sprites = this.assets.sprites[type];

        if (!CharacterClass || !sprites) {
            console.error(`Invalid character type or missing sprites: ${type}`);
            return;
        }

        const character = new CharacterClass(x, y, CONFIG.PLAYER.WIDTH, CONFIG.PLAYER.HEIGHT, sprites, type.toLowerCase());

        if (storedStates) {
            const storedState = storedStates.get(type.toLowerCase());
            if (storedState) {
                Object.assign(character, storedState);
            }
        }

        character.isIdle = false;
        character.isPaused = false;
        character.levelManager = this;

        console.log('Character created:', {
            type: character.type,
            isPaused: character.isPaused,
            isIdle: character.isIdle
        });

        this.characters.push(character);
        return character;
    }

    addRandomCharacter(type, interval) {
        const spawnRandomly = () => {
            if (this.currentLevel !== 1) return;
            const x = Math.random() * (CONFIG.WORLD.WIDTH - CONFIG.PLAYER.WIDTH);
            const y = Math.random() * (CONFIG.WORLD.HEIGHT - CONFIG.PLAYER.HEIGHT);
            this.addCharacter(type, x, y);
        };

        this.characterTimers[type] = setInterval(spawnRandomly, interval);
    }


update(player, worldBounds, input) {
        console.log('LevelManager Update:', {
            isGameStopped: this.isGameStopped(),
            characterCount: this.characters.length,
            characters: this.characters.map(char => ({
                type: char.type,
                position: { x: char.x, y: char.y },
                isPaused: char.isPaused,
                isCaught: char.isCaught
            }))
        });

        if (this.isGameStopped()) {
            console.log('LevelManager Update blocked by isGameStopped');
            return;
        }

        this.characters = this.characters.filter(character => character && character.type);

        console.log('Updating characters:', this.characters.length);

        this.characters.forEach((character) => {
            if (!character.isCaught && !character.isPaused) {
                character.update(player, {
                    width: CONFIG.WORLD.WIDTH,
                    height: CONFIG.WORLD.HEIGHT
                }, input);
            } else {
                console.log('Character update skipped:', {
                    type: character.type,
                    isCaught: character.isCaught,
                    isPaused: character.isPaused
                });
            }
        });

        // Check for level transitions after character updates
        this.checkLevelTransition(player);
    }

    checkLevelTransition(player) {
        if (this.isGameStopped()) return false;

        const currentLevelConfig = CONFIG.LEVELS[this.currentLevel];
        if (!currentLevelConfig || !currentLevelConfig.transitions) {
            return false;
        }

        const gameInstance = window.gameInstance;
        if (!gameInstance?.scoreManager) return false;

        for (const [locationName, transition] of Object.entries(currentLevelConfig.transitions)) {
            if (
                player.x >= transition.x.min &&
                player.x <= transition.x.max &&
                player.y >= transition.y.min &&
                player.y <= transition.y.max
            ) {

                // Check for GUSTO location - Block if energy is ABOVE 30
                if (locationName === 'GUSTO' && gameInstance.scoreManager.scores.energy >= 30) {
                    if (gameInstance.renderer) {
                        gameInstance.renderer.setScreenMessage('gustoClosed');
                    }
                    return false;
                }

                // Check for CHESTER location - Block if friendship is ABOVE 30
                if (locationName === 'CHESTER' && gameInstance.scoreManager.scores.friendship >= 30) {
                    if (gameInstance.renderer) {
                        gameInstance.renderer.setScreenMessage('chesterClosed');
                    }
                    return false;
                }

                this.loadLevel(transition.nextLevel, player);
                return true;
            }
        }

        return false;
    }

    getCurrentLevelBackground() {
        const levelConfig = CONFIG.LEVELS[this.currentLevel];
        if (!levelConfig) {
            console.error(`Level ${this.currentLevel} configuration not found.`);
            return null;
        }

        const backgroundKey = levelConfig.backgroundKey;
        return this.assets.backgrounds[backgroundKey];
    }

    clearTimers() {
        for (const timer in this.characterTimers) {
            clearTimeout(this.characterTimers[timer]);
            clearInterval(this.characterTimers[timer]);
        }
        if (this.friendshipInterval) {
            clearInterval(this.friendshipInterval);
            this.friendshipInterval = null;
        }
        this.characterTimers = {};
    }
}

















// AudioManager.js
import { CONFIG } from '../../config.js';

export class AudioManager {
    constructor() {
        this.sounds = {};
        this.music = {};
        this.audioContext = null;
        this.musicGainNode = null;
        this.sfxGainNode = null;
        this.currentMusicSource = null;
        this.initialized = false;
        this.initializationPromise = null;
    }

    async init() {
        if (this.initializationPromise) {
            return this.initializationPromise;
        }

        // Return if already initialized
        if (this.initialized) {
            return Promise.resolve(true);
        }

        this.initializationPromise = this.performInit();
        return this.initializationPromise;
    }

    async performInit() {
        try {
            console.log('Starting AudioManager initialization...');
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create and connect gain nodes
            this.musicGainNode = this.audioContext.createGain();
            this.sfxGainNode = this.audioContext.createGain();
            this.musicGainNode.connect(this.audioContext.destination);
            this.sfxGainNode.connect(this.audioContext.destination);

            // Set initial volumes
            this.musicGainNode.gain.setValueAtTime(CONFIG.AUDIO.MUSIC_VOLUME, this.audioContext.currentTime);
            this.sfxGainNode.gain.setValueAtTime(CONFIG.AUDIO.SFX_VOLUME, this.audioContext.currentTime);

            // Add user interaction listeners for audio unlock
            const unlockAudio = () => {
                if (this.audioContext?.state === 'suspended') {
                    this.audioContext.resume();
                }
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('touchstart', unlockAudio);
            };

            document.addEventListener('click', unlockAudio);
            document.addEventListener('touchstart', unlockAudio);

            // Load all sounds
            await this.loadAllSounds();
            
            this.initialized = true;
            console.log('AudioManager initialized successfully');
            console.log('Available sounds:', Object.keys(this.sounds));

            return true;
        } catch (error) {
            console.error('AudioManager initialization failed:', error);
            this.initialized = false;
            throw error;
        } finally {
            this.initializationPromise = null;
        }
    }

    async loadAllSounds() {
        console.log('Loading sounds...');
        try {
            const soundsToLoad = [
                ['recharge', './assets/sounds/recharge.mp3'],
                ['buzz', './assets/sounds/buzz.mp3'],
                ['dingdong', './assets/sounds/dingdong.mp3'],
                ['drink', './assets/sounds/drink.mp3'],
                ['prof-theme', './assets/sounds/prof-theme.mp3'],
                ['professore_step', './assets/sounds/prof-step.mp3'],
                ['professore_fuck', './assets/sounds/prof-fuck.mp3'],
                ['professore_smack', './assets/sounds/prof-smack.mp3'],
                ['professore_punch', './assets/sounds/prof-punch.mp3'],
                ['walter_welcome', './assets/sounds/walter-welcome.mp3'],
                ['walter_sound', './assets/sounds/walter-sound.mp3'],
                ['suina_walk', './assets/sounds/suina-walk.mp3'],
                ['suina_sound', './assets/sounds/suina-sound.mp3'],
                ['suina_fuck', './assets/sounds/suina-fuck.mp3'],
                ['suina_evil', './assets/sounds/suina-evil.mp3'],
                ['milly_sound', './assets/sounds/milly-sound.mp3'],
                ['diego_sound', './assets/sounds/diego-sound.mp3'],
                ['win', './assets/sounds/win.mp3']
            ];

            await Promise.all(
                soundsToLoad.map(([key, url]) => 
                    this.loadSound(key, url).catch(error => {
                        console.error(`Failed to load sound ${key}:`, error);
                        return null;
                    })
                )
            );

            console.log('All sounds loaded. Available sounds:', Object.keys(this.sounds));
        } catch (error) {
            console.error('Error loading sounds:', error);
            throw error;
        }
    }

    async loadSound(key, url) {
        try {
            console.log(`Loading sound: ${key}`);
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            this.sounds[key] = audioBuffer;
            console.log(`Loaded sound: ${key}`);
        } catch (error) {
            console.error(`Failed to load sound ${key}:`, error);
            throw error;
        }
    }

    playSound(key, type = 'sfx') {
        if (!this.initialized || !this.sounds[key]) {
            console.warn(`Cannot play sound: ${key}`);
            return;
        }

        try {
            const source = this.audioContext.createBufferSource();
            source.buffer = this.sounds[key];
            source.connect(type === 'music' ? this.musicGainNode : this.sfxGainNode);
            source.start(0);
            console.log(`Playing sound: ${key}`);
        } catch (error) {
            console.error(`Error playing sound ${key}:`, error);
        }
    }

    playBackgroundMusic() {
        if (!this.initialized || !this.sounds['prof-theme']) {
            console.warn('Cannot play background music - system not ready');
            return;
        }

        try {
            if (this.currentMusicSource) {
                this.currentMusicSource.stop();
            }

            this.currentMusicSource = this.audioContext.createBufferSource();
            this.currentMusicSource.buffer = this.sounds['prof-theme'];
            this.currentMusicSource.loop = true;
            this.currentMusicSource.connect(this.musicGainNode);
            this.currentMusicSource.start(0);
            console.log('Background music started');
        } catch (error) {
            console.error('Error playing background music:', error);
        }
    }

    setMusicVolume(volume) {
        if (this.musicGainNode) {
            this.musicGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        }
    }

    setSFXVolume(volume) {
        if (this.sfxGainNode) {
            this.sfxGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        }
    }

    handleFootsteps(player, isMoving) {
        if (isMoving) {
            const now = Date.now();
            if (!this.lastFootstepTime || now - this.lastFootstepTime > CONFIG.AUDIO.FOOTSTEP_INTERVAL) {
                this.playSound('professore_step');
                this.lastFootstepTime = now;
            }
        }
    }
}
























Camera.js:
// Camera.js
import { CONFIG } from '../../config.js';

export class Camera {
    constructor(width, height) {
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.height = height;
    }

    follow(target, worldWidth, worldHeight) {
        const idealX = target.x + target.width / 2 - this.width / 2;
        const idealY = target.y + target.height / 2 - this.height / 2;

        this.x = this.clamp(idealX, 0, Math.max(0, worldWidth - this.width));
        this.y = this.clamp(idealY, 0, Math.max(0, worldHeight - this.height));

        if (worldWidth < this.width) {
            this.x = 0;
        }
        if (worldHeight < this.height) {
            this.y = 0;
        }
    }

    clamp(value, min, max) {
        return Math.max(min, Math.min(value, max));
    }
}













// Input.js
// Input.js
import { CONFIG } from '../../config.js';
import { JoystickController } from './JoystickController.js';

export class InputHandler {
constructor() {
    this.keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        KeyF: false,
        KeyB: false
    };

    this.isMobile = window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT ||
        /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    // Always set up keyboard controls
    this.setupKeyboardControls();
    


    // Set up mobile controls only if needed
    if (this.isMobile) {
        this.joystick = new JoystickController();
        this.setupMobileControls();
    }
}
    

    setupKeyboardControls() {
        window.addEventListener('keydown', (e) => this.setKey(e.code, true));
        window.addEventListener('keyup', (e) => this.setKey(e.code, false));
    }



    setupMobileControls() {
        const actionButtons = {
            'bacio': 'KeyB',
            'fuck': 'KeyF'
        };

        Object.entries(actionButtons).forEach(([buttonId, keyCode]) => {
            const element = document.getElementById(buttonId);
            if (element) {
                ['touchstart', 'mousedown'].forEach(eventType => {
                    element.addEventListener(eventType, (e) => {
                        e.preventDefault();
                        this.setKey(keyCode, true);
                        element.classList.add('active');
                    });
                });

                ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(eventType => {
                    element.addEventListener(eventType, (e) => {
                        e.preventDefault();
                        this.setKey(keyCode, false);
                        element.classList.remove('active');
                    });
                });
            }
        });
    }

    setKey(key, value) {
        if (this.keys.hasOwnProperty(key)) {
            this.keys[key] = value;
        }
    }

    getMovementVector() {
        if (this.isMobile && this.joystick) {
            const joystickInput = this.joystick.getInput();
            return joystickInput.active ? joystickInput.vector : { x: 0, y: 0 };
        }

        const vector = { x: 0, y: 0 };
        if (this.keys.ArrowRight) vector.x += 1;
        if (this.keys.ArrowLeft) vector.x -= 1;
        if (this.keys.ArrowDown) vector.y += 1;
        if (this.keys.ArrowUp) vector.y -= 1;

        if (vector.x !== 0 && vector.y !== 0) {
            const magnitude = Math.sqrt(2);
            vector.x /= magnitude;
            vector.y /= magnitude;
        }

        return vector;
    }

    isMoving() {
        const vector = this.getMovementVector();
        return vector.x !== 0 || vector.y !== 0;
    }

    cleanup() {
        if (this.joystick) {
            this.joystick.joystickContainer.remove();
        }
    }
}












// JoystickController.js
// JoystickController.js
export class JoystickController {
    constructor() {
        this.joystickContainer = null;
        this.joystickBoundary = null;
        this.joystick = null;
        this.knob = null;
        this.touchId = null;
        this.origin = { x: 0, y: 0 };
        this.position = { x: 0, y: 0 };
        this.vector = { x: 0, y: 0 };
        this.active = false;
        this.maxDistance = 60;
        this.sensitivity = 1.5;
        this.visible = false;

        this.createElements();
        this.init();
        this.hideControls();
    }

    createElements() {
        this.joystickContainer = document.createElement('div');
        this.joystickBoundary = document.createElement('div');
        this.joystick = document.createElement('div');
        this.knob = document.createElement('div');
    }

    init() {
        this.joystickContainer.id = 'joystick-zone';
        this.joystickContainer.style.cssText = `
            position: fixed;
            left: 0;
            bottom: 0;
            width: 50%;
            height: 40vh;
            z-index: 1000;
            touch-action: none;
            pointer-events: auto;
        `;

        this.joystickBoundary.className = 'joystick-boundary';
        
        this.joystick.className = 'joystick-base';
        this.joystick.style.display = 'none';

        this.knob.className = 'joystick-knob';

        this.joystick.appendChild(this.knob);
        this.joystickContainer.appendChild(this.joystickBoundary);
        this.joystickContainer.appendChild(this.joystick);
        document.body.appendChild(this.joystickContainer);

        this.setupEventListeners();
    }

    showControls() {
        if (this.joystickContainer && this.joystickBoundary) {
            this.joystickContainer.style.display = 'block';
            this.joystickBoundary.style.display = 'block';
            this.visible = true;
        }
    }

    hideControls() {
        if (this.joystickContainer && this.joystickBoundary) {
            this.joystickContainer.style.display = 'none';
            this.joystickBoundary.style.display = 'none';
            this.visible = false;
        }
    }


    setupEventListeners() {
        ['touchstart', 'mousedown'].forEach(eventType => {
            this.joystickContainer.addEventListener(eventType, (e) => {
                e.preventDefault();
                this.handleStart(eventType === 'touchstart' ? e.touches[0] : e);
            });
        });

        ['touchmove', 'mousemove'].forEach(eventType => {
            this.joystickContainer.addEventListener(eventType, (e) => {
                e.preventDefault();
                if (this.active) {
                    this.handleMove(eventType === 'touchmove' ? e.touches[0] : e);
                }
            });
        });

        ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(eventType => {
            this.joystickContainer.addEventListener(eventType, (e) => {
                e.preventDefault();
                this.handleEnd();
            });
        });
    }

    handleStart(event) {
        if (!this.active) {
            this.active = true;
            this.origin.x = event.clientX;
            this.origin.y = event.clientY;
            
            this.joystick.style.display = 'block';
            this.joystick.style.left = `${this.origin.x - 60}px`;
            this.joystick.style.top = `${this.origin.y - 60}px`;
            
            this.updateJoystickState(event.clientX, event.clientY);
        }
    }

    handleMove(event) {
        this.updateJoystickState(event.clientX, event.clientY);
    }

    handleEnd() {
        this.active = false;
        this.vector = { x: 0, y: 0 };
        this.joystick.style.display = 'none';
        this.knob.style.transform = 'translate(-50%, -50%)';
    }

    updateJoystickState(clientX, clientY) {
        const dx = clientX - this.origin.x;
        const dy = clientY - this.origin.y;
        const distance = Math.min(Math.hypot(dx, dy), this.maxDistance);
        const angle = Math.atan2(dy, dx);

        const knobX = Math.cos(angle) * distance;
        const knobY = Math.sin(angle) * distance;

        this.knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

        this.vector = {
            x: distance > 0 ? (knobX / this.maxDistance) * this.sensitivity : 0,
            y: distance > 0 ? (knobY / this.maxDistance) * this.sensitivity : 0
        };
    }

    getInput() {
        return {
            active: this.active,
            vector: this.vector
        };
    }

    cleanup() {
        if (this.joystickContainer) {
            this.joystickContainer.remove();
        }
    }
}
















// Renderer.js
// Renderer.js
import { CONFIG } from '../../config.js';

export class Renderer {
    constructor(ctx, levelManager, gameState) {
        console.log('Initializing Renderer');
        this.hasShownArrow = false;
        this.ctx = ctx;
        this.levelManager = levelManager;
        this.gameState = gameState;
        this.directions = { down: 0, left: 1, right: 2, up: 3 };
        
        // Mobile controls references
        this.actionContainer = document.getElementById('action-container');
        this.mobileControls = document.getElementById('mobile-controls');
        
        // Initialize controls as hidden
        if (this.actionContainer) this.actionContainer.style.display = 'none';
        if (this.mobileControls) this.mobileControls.style.display = 'none';
        
        // Splash screen properties
        this.splashScreen = null;
        this.splashScreenReady = false;
        this.isSplashVisible = true;
        this.splashDimensions = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        };

        // Win screen properties
        this.winScreen = null;
        this.isWinScreenVisible = false;
        this.hasTriggeredWin = false;
        this.winScreenDimensions = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        };

        this.originalSplashDimensions = {
            width: 1000,
            height: 1800
        };

        this.splashButtons = {
            start: {
                x: 100 / this.originalSplashDimensions.width,
                y: 1110 / this.originalSplashDimensions.height,
                width: 380 / this.originalSplashDimensions.width,
                height: 200 / this.originalSplashDimensions.height
            },
            instructions: {
                x: 520 / this.originalSplashDimensions.width,
                y: 1110 / this.originalSplashDimensions.height,
                width: 380 / this.originalSplashDimensions.width,
                height: 200 / this.originalSplashDimensions.height
            }
        };

        // Win screen button area
        this.winScreenButtons = {
            playAgain: {
                x: 0.35,    // 35% from left
                y: 0.85,    // 85% from top
                width: 0.3, // 30% of screen width
                height: 0.1 // 10% of screen height
            }
        };

        this.canvas = this.ctx.canvas;
        this.canvas.addEventListener('click', (e) => {
            if (this.isWinScreenVisible) {
                this.handleWinScreenClick(e);
            } else if (this.isSplashVisible) {
                this.handleSplashClick(e);
            }
        });
        
        this.screenMessages = {
            diegoWarning: {
                lines: ['Your friend Diego', 'needs your help', 'at the Pub!'],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false
            },
            diegoGameOver: {
                lines: ['Your friend Diego', 'waited for you', "in vain, friendship is", 'broken forever'],
                startTime: 0,
                duration: 3000,
                interval: 400,
                isActive: false,
                nextMessage: 'finalGameOver'
            },
            lowLove: {
                lines: ['Too little love', 'score, Professor'],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false,
                nextMessage: 'finalGameOver'
            },
            lowEnergy: {
                lines: ['Hungry, you need', 'pizza!', 'go to Restaurant!'],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false
            },
            noEnergy: {
                lines: ['Too little energy', 'score, Professor'],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false,
                nextMessage: 'finalGameOver'
            },
            gameOver: {
                lines: ['You caught', 'the Evil Swine... :('],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false,
                nextMessage: 'finalGameOver'
            },
            finalGameOver: {
                lines: ['GAME OVER'],
                startTime: 0,
                duration: Infinity,
                interval: 0,
                isActive: false,
                isPermanent: true,
                showNewGameButton: true
            },
            suinaMala: {
                lines: ['Evil Swine!'],
                startTime: 0,
                duration: 800,
                interval: 200,
                isActive: false
            },
            gustoClosed: {
                lines: ['Restaurant is closed', 'Try again later'],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false
            },
            chesterClosed: {
                lines: ['Pub is closed', 'Try again later'],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false
            }
        };

        // Initialize new game button
        this.newGameButton = {
            element: null,
            visible: false
        };

        this.createNewGameButton();
        this.debug = true;

        // Initialize screens
        this.initializeSplashScreen();
        this.initializeWinScreen();
        
        // Add resize listener
        window.addEventListener('resize', () => this.handleResize());
    }



    updateUIVisibility() {
        const shouldShowControls = !this.isSplashVisible && !this.isWinScreenVisible;
        
        // Update mobile controls visibility
        if (window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT) {
            if (this.actionContainer) {
                this.actionContainer.style.display = shouldShowControls ? 'flex' : 'none';
            }
            if (this.mobileControls) {
                this.mobileControls.style.display = shouldShowControls ? 'block' : 'none';
            }

        // Add joystick control here
        const gameInstance = window.gameInstance;
        if (gameInstance?.input?.joystick) {
    if (shouldShowControls) {
        gameInstance.input.joystick.showControls();
    } else {
        gameInstance.input.joystick.hideControls();
    }
        }




        }

        const gameInstance = window.gameInstance;
        if (gameInstance?.scoreManager) {
            gameInstance.scoreManager.setVisibility(shouldShowControls);
        }

        if (gameInstance?.levelManager) {
            if (this.isSplashVisible || this.isWinScreenVisible) {
                gameInstance.levelManager.pauseFriendshipCountdown();
            } else {
                gameInstance.levelManager.resumeFriendshipCountdown();
            }
        }
    }



    async initAudio() {
        const gameInstance = window.gameInstance;
        if (gameInstance?.audioManager && !gameInstance.audioManager.initialized) {
            try {
                await gameInstance.audioManager.init();
                gameInstance.audioManager.playBackgroundMusic();
            } catch (error) {
                console.error('Failed to initialize audio:', error);
            }
        }
    }

    initializeSplashScreen() {
        const gameInstance = window.gameInstance;
        if (gameInstance?.assets?.sprites?.splash) {
            this.splashScreen = gameInstance.assets.sprites.splash;
            this.calculateSplashDimensions();
            this.splashScreenReady = true;
            this.updateUIVisibility();
            console.log('Splash screen initialized with dimensions:', this.splashDimensions);
        } else {
            console.warn('Splash screen asset not found');
        }
    }

    initializeWinScreen() {
        const gameInstance = window.gameInstance;
        if (gameInstance?.assets?.sprites?.winscreen) {
            this.winScreen = gameInstance.assets.sprites.winscreen;
            this.calculateWinScreenDimensions();
            console.log('Win screen initialized with dimensions:', this.winScreenDimensions);
        } else {
            console.warn('Win screen asset not found');
        }
    }

    calculateWinScreenDimensions() {
        if (!this.winScreen) return;

        const canvasWidth = this.ctx.canvas.width;
        const canvasHeight = this.ctx.canvas.height;
        const imageRatio = this.winScreen.width / this.winScreen.height;
        const canvasRatio = canvasWidth / canvasHeight;

        let newWidth, newHeight;

        if (canvasRatio > imageRatio) {
            newHeight = canvasHeight;
            newWidth = canvasHeight * imageRatio;
        } else {
            newWidth = canvasWidth;
            newHeight = canvasWidth / imageRatio;
        }

        this.winScreenDimensions = {
            width: newWidth,
            height: newHeight,
            x: (canvasWidth - newWidth) / 2,
            y: (canvasHeight - newHeight) / 2
        };
    }

    showWinScreen() {
        const gameInstance = window.gameInstance;
        if (gameInstance?.audioManager?.initialized) {
            if (gameInstance.audioManager.currentMusicSource) {
                gameInstance.audioManager.currentMusicSource.stop();
            }
            gameInstance.audioManager.playSound('win');
        }
        this.isWinScreenVisible = true;
        this.updateUIVisibility();
    }

    handleWinScreenClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;

        if (this.isClickInButton(x, y, this.winScreenButtons.playAgain)) {
            window.location.reload();
        }
    }

    calculateSplashDimensions() {
        if (!this.splashScreen) return;

        const canvasWidth = this.ctx.canvas.width;
        const canvasHeight = this.ctx.canvas.height;
        const imageRatio = this.splashScreen.width / this.splashScreen.height;
        const canvasRatio = canvasWidth / canvasHeight;

        let newWidth, newHeight;

        if (canvasRatio > imageRatio) {
            newHeight = canvasHeight;
            newWidth = canvasHeight * imageRatio;
        } else {
            newWidth = canvasWidth;
            newHeight = canvasWidth / imageRatio;
        }

        this.splashDimensions = {
            width: newWidth,
            height: newHeight,
            x: (canvasWidth - newWidth) / 2,
            y: (canvasHeight - newHeight) / 2
        };
    }

    handleResize() {
        if (this.splashScreenReady) {
            this.calculateSplashDimensions();
        }
        this.calculateWinScreenDimensions();
        this.updateUIVisibility();
    }

    showSuinaMalaMessage() {
        this.setScreenMessage('suinaMala');
    }

    showGameOverMessage() {
        this.setScreenMessage('gameOver');
    }

    showLowLoveMessage() {
        this.setScreenMessage('lowLove');
    }

    showLowEnergyWarning() {
        this.setScreenMessage('lowEnergy');
    }

    showNoEnergyMessage() {
        this.setScreenMessage('noEnergy');
    }

    createNewGameButton() {
        if (this.newGameButton.element) {
            document.body.removeChild(this.newGameButton.element);
        }

        const button = document.createElement('button');
        button.textContent = 'New Game';
        button.style.cssText = `
            position: absolute;
            padding: 10px 20px;
            font-size: 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            font-family: Arial, sans-serif;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s, transform 0.2s;
            z-index: 1000;
        `;

        button.onmouseover = () => {
            button.style.backgroundColor = '#45a049';
            button.style.transform = 'scale(1.05)';
        };
        button.onmouseout = () => {
            button.style.backgroundColor = '#4CAF50';
            button.style.transform = 'scale(1)';
        };

        button.onclick = () => this.handleNewGameClick();

        document.body.appendChild(button);
        this.newGameButton.element = button;
    }

    handleNewGameClick() {
        this.hideNewGameButton();
        if (this.gameState) {
            this.gameState.reset();
        }
        Object.keys(this.screenMessages).forEach(key => {
            this.screenMessages[key].isActive = false;
        });
        window.location.reload();
    }

    showNewGameButton() {
        if (!this.newGameButton.element) return;

        const button = this.newGameButton.element;
        const canvas = this.ctx.canvas;
        
        const rect = canvas.getBoundingClientRect();
        const buttonX = rect.left + (canvas.width / 2);
        const buttonY = rect.top + (canvas.height / 2) + 50;

        button.style.left = `${buttonX}px`;
        button.style.top = `${buttonY}px`;
        button.style.transform = 'translate(-50%, -50%)';
        button.style.display = 'block';
        
        this.newGameButton.visible = true;
    }

    hideNewGameButton() {
        if (this.newGameButton.element) {
            this.newGameButton.element.style.display = 'none';
            this.newGameButton.visible = false;
        }
    }

    setScreenMessage(type) {
        if (!this.screenMessages[type]) return;
        
        const message = this.screenMessages[type];
        message.startTime = performance.now();
        message.isActive = true;
    }

    drawScreenMessage(type) {
        const message = this.screenMessages[type];
        if (!message || !message.isActive) return;

        const currentTime = performance.now();
        const elapsed = currentTime - message.startTime;
        
        if (elapsed > message.duration && !message.isPermanent) {
            message.isActive = false;
            
            if (message.nextMessage) {
                this.setScreenMessage(message.nextMessage);
            }
            return;
        }

        const isVisible = message.isPermanent || 
                         message.interval === 0 || 
                         (Math.floor(elapsed / message.interval) % 2 === 0);
        
        if (isVisible) {
            this.ctx.save();
            this.ctx.font = 'bold 32px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 3;
            
const x = this.ctx.canvas.width / 2;
            const baseY = this.ctx.canvas.height / 2;

            message.lines.forEach((line, index) => {
                const y = baseY + (index - (message.lines.length - 1) / 2) * 40;
                this.ctx.strokeText(line, x, y);
                this.ctx.fillText(line, x, y);
            });
            
            this.ctx.restore();

            if (message.showNewGameButton && !this.newGameButton.visible) {
                this.showNewGameButton();
            }
        }
    }

    draw(player, sprites, camera) {
        this.clear();
        
        this.drawBackground(this.levelManager.getCurrentLevelBackground(), camera);
        
        if (this.levelManager?.characters) {
            this.drawCharacters(camera);
        }
        
        if (player && sprites.professore) {
            this.drawPlayer(player, sprites.professore, camera);
        }

        const gameInstance = window.gameInstance;
        if (!this.hasTriggeredWin && gameInstance?.scoreManager?.scores?.love >= 100) {
            this.showWinScreen();
            this.hasTriggeredWin = true;
        }

        if (this.isWinScreenVisible && this.winScreen) {
            this.ctx.drawImage(
                this.winScreen,
                this.winScreenDimensions.x,
                this.winScreenDimensions.y,
                this.winScreenDimensions.width,
                this.winScreenDimensions.height
            );
            return;
        }
        
        if (!this.isSplashVisible) {
            Object.keys(this.screenMessages).forEach(type => {
                this.drawScreenMessage(type);
            });
        }

        if (this.isSplashVisible) {
            this.drawSplashScreen();
        }
    }

    drawBackground(background, camera) {
        if (background) {
            this.ctx.drawImage(
                background,
                camera.x, camera.y,
                camera.width, camera.height,
                0, 0,
                camera.width, camera.height
            );
        }

        if (this.levelManager?.currentLevel === 1 && !this.hasShownArrow) {
            const currentTime = performance.now();
            const isVisible = Math.floor(currentTime / 500) % 2 === 0;
            
            if (isVisible) {
                this.ctx.save();
                this.ctx.font = 'bold 48px Arial';
                this.ctx.fillStyle = 'white';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('↖️', 100, 200);
                this.ctx.restore();
            }
        }
    }

    handleSplashClick(e) {
        if (!this.isSplashVisible) return;

        if (this.showingInstructions) {
            this.setSplashVisibility(false);
            this.initAudio();
            return;
        }

        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;

        if (this.isClickInButton(x, y, this.splashButtons.start)) {
            this.setSplashVisibility(false);
            this.initAudio();
            return;
        }

        if (this.isClickInButton(x, y, this.splashButtons.instructions)) {
            this.showInstructions();
            return;
        }
    }

    isClickInButton(x, y, button) {
        if (this.isSplashVisible) {
            const actualX = this.splashDimensions.x + (button.x * this.splashDimensions.width);
            const actualY = this.splashDimensions.y + (button.y * this.splashDimensions.height);
            const actualWidth = button.width * this.splashDimensions.width;
            const actualHeight = button.height * this.splashDimensions.height;

            return x >= actualX && 
                   x <= actualX + actualWidth && 
                   y >= actualY && 
                   y <= actualY + actualHeight;
        } else if (this.isWinScreenVisible) {
            const actualX = this.winScreenDimensions.x + (button.x * this.winScreenDimensions.width);
            const actualY = this.winScreenDimensions.y + (button.y * this.winScreenDimensions.height);
            const actualWidth = button.width * this.winScreenDimensions.width;
            const actualHeight = button.height * this.winScreenDimensions.height;

            return x >= actualX && 
                   x <= actualX + actualWidth && 
                   y >= actualY && 
                   y <= actualY + actualHeight;
        }
        return false;
    }

    showInstructions() {
        const gameInstance = window.gameInstance;
        if (gameInstance?.assets?.sprites?.instructions) {
            this.splashScreen = gameInstance.assets.sprites.instructions;
            this.calculateSplashDimensions();
            this.showingInstructions = true;
        }
    }

    drawSplashScreen() {
        if (this.splashScreenReady && this.splashScreen && this.isSplashVisible) {
            this.ctx.drawImage(
                this.splashScreen,
                this.splashDimensions.x,
                this.splashDimensions.y,
                this.splashDimensions.width,
                this.splashDimensions.height
            );
        }
    }

    setSplashVisibility(visible) {
        this.isSplashVisible = visible;
        this.updateUIVisibility();
    }

    drawPlayer(player, sprites, camera) {
        if (!player) return;

        const drawX = player.x - camera.x;
        const drawY = player.y - camera.y;

        if (this.gameState?.isGameOver && 
            this.gameState.gameOverType === 'jail' && 
            player.freeze) {
            
            if (sprites.freeze) {
                this.ctx.drawImage(sprites.freeze, drawX, drawY, player.width, player.height);
                
                const jailOverlay = this.gameState.getJailOverlay();
                if (jailOverlay) {
                    const overlayWidth = player.width * 1.5;
                    const overlayHeight = player.height * 1.5;
                    const overlayX = drawX - (overlayWidth - player.width) / 2;
                    const overlayY = drawY - (overlayHeight - player.height) / 2;
                    
                    this.ctx.drawImage(
                        jailOverlay, 
                        overlayX, overlayY, 
                        overlayWidth, overlayHeight
                    );
                }
            }
            return;
        }

        if (player.isIdle) {
            if (sprites.idle) {
                this.ctx.drawImage(sprites.idle, drawX, drawY, player.width, player.height);
            }
        } else {
            const directionIndex = this.directions[player.direction] || this.directions['down'];
            const spriteX = player.frame * player.width;
            const spriteY = directionIndex * player.height;

            if (sprites.walking) {
                this.ctx.drawImage(
                    sprites.walking,
                    spriteX, spriteY,
                    player.width, player.height,
                    drawX, drawY,
                    player.width, player.height
                );
            }
        }
    }

    drawCharacters(camera) {
        if (!this.levelManager?.characters) return;
        
        this.levelManager.characters.forEach(character => {
            if (!character || !character.type || !character.isVisible) return;

            const drawX = character.x - camera.x;
            const drawY = character.y - camera.y;

            if (character.currentSprite === 'attack' && character.activeSprite) {
                this.ctx.drawImage(character.activeSprite, drawX, drawY, 
                    character.width, character.height);
                return;
            }

            if (character.isIdle && character.sprites?.idle) {
                this.ctx.drawImage(character.sprites.idle, drawX, drawY, 
                    character.width, character.height);
            } else if (character.sprites?.walking) {
                const directionIndex = this.directions[character.direction] || this.directions['down'];
                const spriteX = character.frame * character.width;
                const spriteY = directionIndex * character.height;

                this.ctx.drawImage(
                    character.sprites.walking,
                    spriteX, spriteY,
                    character.width, character.height,
                    drawX, drawY,
                    character.width, character.height
                );
            }
        });
    }

    setFlashStartTime() {
        const startTime = performance.now();
        this.screenMessages.gameOver.startTime = startTime;
        if (this.debug) {
            console.log('Flash start time set to:', startTime);
        }
    }

    clear() {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }

    cleanup() {
        window.removeEventListener('resize', () => this.handleResize());
        
        if (this.newGameButton.element) {
            document.body.removeChild(this.newGameButton.element);
            this.newGameButton.element = null;
        }

        if (this.actionContainer) {
            this.actionContainer.style.display = 'none';
        }

        if (this.mobileControls) {
            this.mobileControls.style.display = 'none';
        }

        this.splashScreenReady = false;
        this.splashScreen = null;
        this.isSplashVisible = false;
    }
}
























ScoreManager.js:
// ScoreManager.js
import { ScoreAnimation } from './ScoreAnimation.js';

export class ScoreManager {
    constructor(ctx) {
        this.ctx = ctx;
        this.scores = {
            energy: 100,    // Starting at 100
            love: 0,        // Starting at 0
            friendship: 100  // Starting at 100
        };
        this.maxScore = 100;
        this.barWidth = 150;
        this.barHeight = 10;
        this.padding = 10;
        this.colors = {
            energy: '#FFA07A',    // Light Orange for Energy
            love: '#ff69b4',      // Pink for Love
            friendship: '#90EE90'  // Light Green for Friendship
        };
        this.barSpacing = 5;
        this.textPadding = 5;
        this.lastCountdownTime = performance.now();
        this.warningShown = false;
        this.energyWarningShown = false;
        this.gameOverTriggered = false;
        this.energyCountdownStarted = false;
        this.energyCountdownInterval = null;
        this.isInTransition = false;
        this.transitionScores = null;

        // Flash states for score bars
        this.flashStates = {
            energy: { isFlashing: false, flashCount: 0, lastFlashTime: 0 },
            love: { isFlashing: false, flashCount: 0, lastFlashTime: 0 },
            friendship: { isFlashing: false, flashCount: 0, lastFlashTime: 0 }
        };
        
        this.flashConfig = {
            totalFlashes: 3,
            flashDuration: 400,
            flashInterval: 800
        };
        
        this.scoreAnimation = new ScoreAnimation();
        this.startFriendshipCountdown();
    }

    setTransitionState(isInTransition) {
        console.log('Setting transition state:', isInTransition);
        this.isInTransition = isInTransition;
        if (isInTransition) {
            this.transitionScores = { ...this.scores };
        }
    }

    restoreTransitionScores() {
        if (this.transitionScores) {
            console.log('Restoring transition scores');
            this.scores = { ...this.transitionScores };
            this.transitionScores = null;
        }
    }

    startBarFlash(type) {
        console.log(`Starting flash for ${type}`);
        this.flashStates[type] = {
            isFlashing: true,
            flashCount: 0,
            lastFlashTime: performance.now()
        };
    }

    increaseScore(type, amount) {
        if (this.scores.hasOwnProperty(type)) {
            const oldScore = this.scores[type];
            
            if (type === 'love' && amount > 0) {
                const actualLoveIncrease = Math.min(this.maxScore, oldScore + amount) - oldScore;
                const energyDecrease = actualLoveIncrease;
                
                const newEnergy = Math.max(0, this.scores.energy - energyDecrease);
                if (newEnergy === 0 && this.scores.energy > 0) {
                    this.startBarFlash('energy');
                }
                this.scores.energy = newEnergy;
                
                this.scores[type] = Math.min(this.maxScore, oldScore + amount);
                this.scoreAnimation.addAnimation(amount);
            } else {
                const newScore = Math.min(this.maxScore, oldScore + amount);
                if (newScore === 0 && oldScore > 0) {
                    this.startBarFlash(type);
                }
                this.scores[type] = newScore;
                
                if (type === 'energy' && amount > 0 && this.scores.energy > 30) {
                    this.stopEnergyCountdown();
                    this.energyWarningShown = false;
                }
            }
            
            this.checkScores();
        }
    }

    startEnergyCountdown() {
        if (this.energyCountdownStarted) return;
        
        this.energyCountdownStarted = true;
        const countdownInterval = 1000;

        this.energyCountdownInterval = setInterval(() => {
            const gameInstance = window.gameInstance;
            if (gameInstance?.gameState?.isGameOver) {
                this.stopEnergyCountdown();
                return;
            }

            if (this.scores.energy > 0) {
                this.scores.energy--;
                
                if (this.scores.energy === 0 && !this.gameOverTriggered) {
                    this.startBarFlash('energy');
                    this.gameOverTriggered = true;
                    this.triggerGameOver('energy');
                }
            } else {
                this.stopEnergyCountdown();
            }
        }, countdownInterval);
    }

    stopEnergyCountdown() {
        if (this.energyCountdownInterval) {
            clearInterval(this.energyCountdownInterval);
            this.energyCountdownInterval = null;
        }
        this.energyCountdownStarted = false;
    }



checkScores() {
        const gameInstance = window.gameInstance;
        if (!gameInstance || this.isInTransition) return;

        // Check if we're in Level 5 with Diego
        const isLevel5WithDiego = gameInstance.levelManager?.currentLevel === 5 && 
            gameInstance.levelManager.characters.some(c => c.type === 'diego');

        // Check Love score only when not in Diego's level and not during transitions
        if (!isLevel5WithDiego && this.scores.love <= 0 && !this.gameOverTriggered) {
            console.log('Love score triggered game over');
            this.startBarFlash('love');
            this.gameOverTriggered = true;
            this.triggerGameOver('love');
        }

        // Check Energy warnings and game over
        if (this.scores.energy <= 30) {
            this.startBarFlash('energy');
            if (gameInstance.renderer) {
                gameInstance.renderer.showLowEnergyWarning();
            }
            if (gameInstance.audioManager) {
                gameInstance.audioManager.playSound('dingdong');
            }
            this.startEnergyCountdown();
        }

        if (this.scores.energy <= 0 && !this.gameOverTriggered) {
            console.log('Energy score triggered game over');
            this.startBarFlash('energy');
            this.gameOverTriggered = true;
            this.triggerGameOver('energy');
        }

        // Check Friendship at 30
        if (this.scores.friendship <= 30) {
            this.startBarFlash('friendship');
            if (gameInstance?.renderer) {
                gameInstance.renderer.setScreenMessage('diegoWarning');
            }
            if (gameInstance?.audioManager) {
                gameInstance.audioManager.playSound('dingdong');
            }
        }
    }



startFriendshipCountdown() {
    const countdownInterval = 1000;
    this.countdownInterval = setInterval(() => {
        const gameInstance = window.gameInstance;
        if (gameInstance?.gameState?.isGameOver) {
            clearInterval(this.countdownInterval);
            return;
        }

        // Don't decrease friendship in level 5
        if (gameInstance?.levelManager?.currentLevel === 5) {
            return;
        }

        if (this.scores.friendship > 0) {
            this.scores.friendship--;

            if (this.scores.friendship === 30 && !this.warningShown) {
                this.warningShown = true;
                this.startBarFlash('friendship');
                if (gameInstance?.renderer) {
                    gameInstance.renderer.setScreenMessage('diegoWarning');
                }
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('dingdong');
                }
            }

            if (this.scores.friendship === 0 && !this.gameOverTriggered) {
                console.log('Friendship score triggered game over');
                this.gameOverTriggered = true;
                this.startBarFlash('friendship');

                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('buzz');
                }

                if (gameInstance?.renderer) {
                    gameInstance.renderer.setScreenMessage('diegoGameOver');
                }
                if (gameInstance?.gameState) {
                    gameInstance.gameState.isGameOver = true;
                    setTimeout(() => {
                        if (gameInstance.audioManager) {
                            gameInstance.audioManager.playSound('suina_evil');
                        }
                        gameInstance.renderer.setScreenMessage('finalGameOver');
                        gameInstance.renderer.showNewGameButton();
                    }, 3000);
                }
            }
        }
    }, countdownInterval);
}




    triggerGameOver(type) {
        const gameInstance = window.gameInstance;
        if (!gameInstance) return;

        if (gameInstance.audioManager) {
            gameInstance.audioManager.playSound('buzz');
        }

        if (gameInstance.renderer) {
            if (type === 'love') {
                gameInstance.renderer.showLowLoveMessage();
            } else if (type === 'energy') {
                gameInstance.renderer.showNoEnergyMessage();
            }
        }

        if (gameInstance.audioManager?.currentMusicSource) {
            const gainNode = gameInstance.audioManager.musicGainNode;
            const currentTime = gameInstance.audioManager.audioContext.currentTime;
            gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
            gainNode.gain.linearRampToValueAtTime(0, currentTime + 1);
            
            setTimeout(() => {
                if (gameInstance.audioManager.currentMusicSource) {
                    gameInstance.audioManager.currentMusicSource.stop();
                }
            }, 1000);
        }

        if (gameInstance.gameState) {
            gameInstance.gameState.isGameOver = true;
            setTimeout(() => {
                if (gameInstance.audioManager) {
                    gameInstance.audioManager.playSound('suina_evil');
                }
                gameInstance.renderer.setScreenMessage('finalGameOver');
                gameInstance.renderer.showNewGameButton();
            }, 2000);
        }
    }

setVisibility(visible) {
    this.isVisible = visible;
}

    draw() {
    if (!this.isVisible) return;
        this.ctx.save();

        // Draw love score at top
        const loveScore = Math.round(this.scores.love);
        this.ctx.fillStyle = '#FF0000'; // Red heart
        this.ctx.font = 'bold 24px Arial';
        this.ctx.textAlign = 'center';
        const topPadding = 35;
        const leftOffset = 90;
        this.ctx.fillText('♥', leftOffset - 12, topPadding); // Heart symbol
        this.ctx.fillStyle = '#FF0000';
        this.ctx.fillText(loveScore, leftOffset + 12, topPadding);

        // Draw score bars
        Object.entries(this.scores).forEach(([type, score], index) => {
            const x = this.ctx.canvas.width - this.barWidth - this.padding;
            const y = this.padding + (index * (this.barHeight + this.barSpacing));
            const flashState = this.flashStates[type];

            // Draw label
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = 'bold 10px Arial';
            this.ctx.textAlign = 'right';
            this.ctx.fillText(type.toUpperCase(), x - this.textPadding, y + this.barHeight);

            // Handle flash states and bar drawing
            let shouldShow = true;
            let isFlashFrame = false;
            if (flashState.isFlashing) {
                const elapsed = performance.now() - flashState.lastFlashTime;
                const currentFlashCycle = Math.floor(elapsed / this.flashConfig.flashInterval);
                shouldShow = Math.floor((elapsed % this.flashConfig.flashInterval) / this.flashConfig.flashDuration) === 0;
                isFlashFrame = shouldShow;

                if (currentFlashCycle >= this.flashConfig.totalFlashes) {
                    flashState.isFlashing = false;
                    shouldShow = true;
                    isFlashFrame = false;
                }
            }

            // Draw the bars
            if (shouldShow) {
                const scoreValue = Math.round(score);
                const fillWidth = (score / this.maxScore) * this.barWidth;
                const emptyWidth = this.barWidth - fillWidth;
                
                if (flashState.isFlashing) {
                    if (fillWidth > 0) {
                        this.ctx.fillStyle = this.colors[type];
                        this.ctx.fillRect(x, y, fillWidth, this.barHeight);
                        
                        // Draw score number inside the filled portion
                        this.ctx.fillStyle = '#000000';
                        this.ctx.font = 'bold 8px Arial';
                        this.ctx.textAlign = 'left';
                        this.ctx.fillText(scoreValue, x + 2, y + this.barHeight - 2);
                    }
                    
                    if (emptyWidth > 0) {
                        this.ctx.fillStyle = isFlashFrame ? '#FF0000' : 'rgba(0, 0, 0, 0.3)';
                        this.ctx.fillRect(x + fillWidth, y, emptyWidth, this.barHeight);
                    }
                } else {
                    if (fillWidth > 0) {
                        this.ctx.fillStyle = this.colors[type];
                        this.ctx.fillRect(x, y, fillWidth, this.barHeight);
                        
                        // Draw score number inside the filled portion
                        this.ctx.fillStyle = '#000000';
                        this.ctx.font = 'bold 8px Arial';
                        this.ctx.textAlign = 'left';
                        this.ctx.fillText(scoreValue, x + 2, y + this.barHeight - 2);
                    }
                    if (emptyWidth > 0) {
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.fillRect(x + fillWidth, y, emptyWidth, this.barHeight);
                    }
                }
            }
        });

        this.scoreAnimation.update(this.ctx);
        this.ctx.restore();
    }

    cleanup() {
        if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
        }
        this.stopEnergyCountdown();
        Object.keys(this.flashStates).forEach(type => {
            this.flashStates[type] = { isFlashing: false, flashCount: 0, lastFlashTime: 0 };
        });
    }
}













ScoreAnimation.js:
// ScoreAnimation.js
export class ScoreAnimation {
    constructor() {
        this.animations = [];
        this.scoreCountdownElement = null;
        this.isResetting = false;
        this.countdownAnimationFrame = null;
    }

    addAnimation(score, isNegative = false) {
        const canvas = document.getElementById('gameCanvas');
        const isLevel5 = window.gameInstance?.levelManager?.currentLevel === 5;
        
        // Only apply special animation in Level 5
        if (isLevel5 && window.gameInstance?.levelManager?.characters.some(c => c.type === 'diego')) {
            if (isNegative) {
                // Energy loss animation (left side)
                this.animations.push({
                    score: `-${score}`,
                    x: Math.round(canvas.width / 2 - 50), // Offset left
                    y: Math.round(canvas.height / 2),
                    startTime: performance.now(),
                    duration: 2000,
                    startFontSize: 72,
                    endFontSize: 24,
                    opacity: 1,
                    color: '#FF0000' // Light Orange for Energy
                });
            } else {
                // Friendship gain animation (right side)
                this.animations.push({
                    score: `+${score}`,
                    x: Math.round(canvas.width / 2 + 50), // Offset right
                    y: Math.round(canvas.height / 2),
                    startTime: performance.now(),
                    duration: 2000,
                    startFontSize: 24,
                    endFontSize: 72,
                    opacity: 1,
                    color: '#90EE90' // Light Green for Friendship
                });
            }
        } else {
            // Default animation for other scenarios
            this.animations.push({
                score: `${isNegative ? '-' : '+'}${score}`,
                x: Math.round(canvas.width / 2),
                y: Math.round(canvas.height / 2),
                startTime: performance.now(),
                duration: 2000,
                startFontSize: 72,
                endFontSize: 24,
                opacity: 1,
                color: isNegative ? '#FFA07A' : '#90EE90'
            });
        }
    }

    update(ctx) {
        const currentTime = performance.now();
        
        for (let i = this.animations.length - 1; i >= 0; i--) {
            const anim = this.animations[i];
            const elapsed = currentTime - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);

            // Smooth easing function
            const easeOutCubic = 1 - Math.pow(1 - progress, 3);

            // Calculate current font size
            const fontSize = Math.round(
                anim.startFontSize + (anim.endFontSize - anim.startFontSize) * easeOutCubic
            );
            
            // Calculate opacity (fade out in the last 30% of animation)
            anim.opacity = progress > 0.7 ? 1 - ((progress - 0.7) / 0.3) : 1;

            ctx.save();
            
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Move upward as it fades
            const yOffset = 50 * easeOutCubic;

            // Draw text outline
            ctx.strokeStyle = `rgba(0, 0, 0, ${anim.opacity * 0.5})`;
            ctx.lineWidth = 3;
            ctx.strokeText(anim.score, anim.x, anim.y - yOffset);

            // Draw text fill with specified color
            ctx.fillStyle = `rgba(${this.hexToRgb(anim.color)}, ${anim.opacity})`;
            ctx.fillText(anim.score, anim.x, anim.y - yOffset);

            ctx.restore();

            if (progress >= 1) {
                this.animations.splice(i, 1);
            }
        }
    }

    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? 
            `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
            '255, 255, 255';
    }



    animateScoreReset(scoreManager, onComplete) {
        if (this.isResetting) return;
        
        this.isResetting = true;
        const scores = scoreManager.scores;
        const startScores = { ...scores };
        const animationDuration = 2000;
        const startTime = performance.now();
        const startFontSize = 120; // Starting larger
        const endFontSize = 48;   // Ending smaller

        this.createCountdownElement(startFontSize);

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);

            // Easing function for smooth animation
            const easeInOutQuad = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            // Animate scores down
            Object.keys(scores).forEach(type => {
                scores[type] = Math.round(startScores[type] * (1 - easeInOutQuad));
            });

            // Update countdown number with size and opacity animation
            const countdownValue = Math.round(100 * (1 - easeInOutQuad));
            if (this.scoreCountdownElement) {
                // Calculate current font size
                const currentFontSize = startFontSize - (startFontSize - endFontSize) * easeInOutQuad;
                
                // Calculate opacity (start fading halfway through)
                const opacity = progress > 0.5 ? 2 * (1 - progress) : 1;
                
                this.scoreCountdownElement.style.fontSize = `${currentFontSize}px`;
                this.scoreCountdownElement.style.opacity = opacity;
                this.scoreCountdownElement.textContent = countdownValue;
            }

            if (progress < 1) {
                this.countdownAnimationFrame = requestAnimationFrame(animate);
            } else {
                this.cleanup();
                this.isResetting = false;
                if (onComplete) onComplete();
            }
        };

        this.countdownAnimationFrame = requestAnimationFrame(animate);
    }

    createCountdownElement(fontSize) {
        this.scoreCountdownElement = document.createElement('div');
        this.scoreCountdownElement.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: ${fontSize}px;
            font-family: 'Arial Black', Arial;
            color: white;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5),
                         -3px -3px 6px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transition: transform 0.1s ease-out;
            opacity: 1;
        `;
        document.body.appendChild(this.scoreCountdownElement);
    }


    cleanup() {
        if (this.countdownAnimationFrame) {
            cancelAnimationFrame(this.countdownAnimationFrame);
            this.countdownAnimationFrame = null;
        }
        
        if (this.scoreCountdownElement) {
            document.body.removeChild(this.scoreCountdownElement);
            this.scoreCountdownElement = null;
        }
    }
}












GameStateManager.js:
// GameStateManager.js
export class GameStateManager {
    constructor(game) {
        this.game = game;
        this.isGameOver = false;
        this.gameOverType = null;
        this.jailOverlay = null;
        this.transitionState = {
            active: false,
            startTime: null,
            duration: 1000
        };
        this.initializeJailOverlay();  // Changed name to be more accurate
    }

    initializeJailOverlay() {  // Renamed method
        try {
            this.jailOverlay = new Image();
            this.jailOverlay.src = './assets/sprites/jail.png';
            
            this.jailOverlay.onload = () => {
                console.log('Jail overlay loaded successfully');
            };
            
            this.jailOverlay.onerror = (error) => {
                console.error('Failed to load jail overlay:', error);
            };
        } catch (error) {
            console.error('Error initializing jail overlay:', error);
        }
    }

    triggerJailGameOver(player) {
        console.log('Triggering jail game over sequence');
        if (this.isGameOver) return;

        this.isGameOver = true;
        this.gameOverType = 'jail';
        this.transitionState.active = true;
        this.transitionState.startTime = performance.now();

        // Use the centralized message system
        if (this.game.renderer) {
            this.game.renderer.showGameOverMessage();
        }

        // Set flash start time in renderer
        if (this.game.renderer) {
            console.log('Setting flash start time');
            this.game.renderer.setFlashStartTime();
        } else {
            console.warn('Renderer not available for flash timing');
        }

        // Handle player state
        if (player) {
            console.log('Setting player game over state');
            player.freeze = true;
            player.isIdle = true;
            player.velocity = { x: 0, y: 0 };
            player.movementBuffer = { x: 0, y: 0 };
        }

        // Stop background music with fade out
        if (this.game.audioManager?.currentMusicSource) {
            const gainNode = this.game.audioManager.musicGainNode;
            const currentTime = this.game.audioManager.audioContext.currentTime;
            gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
            gainNode.gain.linearRampToValueAtTime(0, currentTime + 1);
            
            setTimeout(() => {
                this.game.audioManager.currentMusicSource.stop();
            }, 1000);
        }

        // Animate score reset
        if (this.game.scoreManager) {
            this.game.scoreManager.scoreAnimation.animateScoreReset(
                this.game.scoreManager,
                () => {
                    console.log('Score reset animation complete');
                    this.transitionState.active = false;
                }
            );
        }
    }

    isInTransition() {
        if (!this.transitionState.active) return false;
        const elapsed = performance.now() - this.transitionState.startTime;
        return elapsed < this.transitionState.duration;
    }

    getJailOverlay() {
        return this.jailOverlay?.complete ? this.jailOverlay : null;
    }

    reset() {
        this.isGameOver = false;
        this.gameOverType = null;
        this.transitionState.active = false;
        this.transitionState.startTime = null;

        // Reset player state if available
        if (this.game?.player) {
            this.game.player.freeze = false;
            if (this.game.assets?.sprites?.professore) {
                this.game.player.sprites = this.game.assets.sprites.professore;
            }
        }

        // Reset score animation if available
        if (this.game?.scoreManager?.scoreAnimation) {
            this.game.scoreManager.scoreAnimation.cleanup();
        }

        // Reset audio if available
        if (this.game?.audioManager) {
            this.game.audioManager.musicGainNode.gain.setValueAtTime(
                this.game.audioManager.musicGainNode.gain.defaultValue,
                this.game.audioManager.audioContext.currentTime
            );
        }
    }
}














BaseCharacter.js:
// BaseCharacter.js
import { CONFIG } from '../config.js';

export class BaseCharacter {
    constructor(x, y, width, height, sprites, type, speedMultiplier = 1) {
        console.log('BaseCharacter Constructor:', {
            x, y, width, height, type, speedMultiplier
        });

        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.sprites = sprites;
        this.type = type.toLowerCase();

        // Movement and animation
        this.speed = CONFIG.PLAYER.SPEED * speedMultiplier;
        this.direction = 'down';
        this.isIdle = true;
        this.frame = 0;
        this.totalFrames = CONFIG.PLAYER.TOTAL_FRAMES;
        this.animationSpeed = 100;
        this.lastAnimationUpdate = performance.now();
        this.isCaught = false;
        this.isPaused = false;

        console.log('BaseCharacter Initialized:', {
            speed: this.speed,
            direction: this.direction,
            isIdle: this.isIdle,
            totalFrames: this.totalFrames,
            isPaused: this.isPaused
        });
    }

update(player, worldBounds, input) {
        console.log('BaseCharacter Update ENTRY:', {
            type: this.type,
            isPaused: this.isPaused,
            isCaught: this.isCaught,
            isVisible: this.isVisible,
            position: { x: this.x, y: this.y }
        });

        if (this.isPaused || this.isCaught) {
            console.log('BaseCharacter Update BLOCKED by:', {
                isPaused: this.isPaused,
                isCaught: this.isCaught
            });
            return;
        }

        const currentTime = performance.now();
        const deltaTime = Math.min((currentTime - (this.lastUpdateTime || currentTime)) / 16.67, 32);
        this.lastUpdateTime = currentTime;

        console.log('BaseCharacter calling updateBehavior with:', {
            deltaTime,
            currentTime,
            lastUpdateTime: this.lastUpdateTime
        });

        this.updateBehavior(player, worldBounds, deltaTime, input);

        console.log('BaseCharacter after updateBehavior:', {
            isIdle: this.isIdle,
            frame: this.frame,
            position: { x: this.x, y: this.y }
        });

        if (!this.isIdle) {
            if (currentTime - this.lastAnimationUpdate >= this.animationSpeed) {
                this.frame = (this.frame + 1) % this.totalFrames;
                this.lastAnimationUpdate = currentTime;
                console.log('BaseCharacter animation updated:', {
                    frame: this.frame,
                    animationTime: currentTime - this.lastAnimationUpdate
                });
            }
        }
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        console.log('BaseCharacter updateBehavior called');
        this.isIdle = true;
    }

    checkCollision(other) {
        const collision = (
            this.x < other.x + other.width &&
            this.x + this.width > other.x &&
            this.y < other.y + other.height &&
            this.y + this.height > other.y
        );
        
        if (collision) {
            console.log('Collision detected:', {
                myPos: { x: this.x, y: this.y },
                otherPos: { x: other.x, y: other.y }
            });
        }
        
        return collision;
    }

    pauseUpdates() {
        console.log('Character paused');
        this.isPaused = true;
    }

    resumeUpdates() {
        console.log('Character resumed');
        this.isPaused = false;
        this.lastUpdateTime = performance.now();
        this.lastAnimationUpdate = performance.now();
    }

    cleanup() {
        console.log('Character cleanup');
        this.isPaused = false;
    }
}











// Player.js
// Player.js
import { CONFIG } from '../config.js';
import { BaseCharacter } from './BaseCharacter.js';

export class Player extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
        this.lastUpdateTime = performance.now();
        this.frameTime = performance.now();
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.currentInput = null;
        this.updateSpeedMultiplier();
        this.spriteState = {
            current: 'idle',
            frame: 0,
            lastUpdate: performance.now()
        };
    }

    forceStateUpdate() {
        const now = performance.now();
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.lastAnimationUpdate = now;
        this.spriteState.lastUpdate = now;
        
        // Update sprite state based on current movement
        this.updateSpriteState(!this.isIdle);
    }

    updateSpriteState(isMoving) {
        const now = performance.now();
        const spriteType = isMoving ? 'walking' : 'idle';
        
        // Only update if state actually changed
        if (this.spriteState.current !== spriteType) {
            this.spriteState.current = spriteType;
            this.spriteState.frame = 0;
            this.spriteState.lastUpdate = now;
            this.frame = 0; // Reset animation frame
        }
    }

    determineSpeedMultiplier() {
        const screenWidth = window.innerWidth;
        if (screenWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT) {
            return CONFIG.PLAYER.SPEED_MULTIPLIERS.MOBILE;
        } else if (screenWidth <= 1024) {
            return CONFIG.PLAYER.SPEED_MULTIPLIERS.TABLET;
        }
        return CONFIG.PLAYER.SPEED_MULTIPLIERS.DESKTOP;
    }

    updateSpeedMultiplier() {
        this.speedMultiplier = this.determineSpeedMultiplier();
        this.speed = CONFIG.PLAYER.SPEED * this.speedMultiplier;
    }

    update(input, worldBounds) {
        const currentTime = performance.now();
        
        // Limit deltaTime to prevent extreme values
        const maxDeltaTime = 32;
        const rawDeltaTime = (currentTime - this.lastUpdateTime) / 16.67;
        const deltaTime = Math.min(rawDeltaTime, maxDeltaTime);
        
        this.lastUpdateTime = currentTime;
        this.frameTime += deltaTime * 16.67;

        // Store previous state
        const wasMoving = !this.isIdle;
        
        // Update movement and state
        this.updateBehavior(input, worldBounds, deltaTime);
        
        // Check if movement state changed
        const isMoving = !this.isIdle;
        if (wasMoving !== isMoving) {
            this.updateSpriteState(isMoving);
        }

        // Update animation
        if (isMoving) {
            if (currentTime - this.spriteState.lastUpdate >= this.animationSpeed) {
                this.frame = (this.frame + 1) % this.totalFrames;
                this.spriteState.lastUpdate = currentTime;
            }
        }
    }



updateBehavior(input, worldBounds, deltaTime) {
    if (this.freeze) {
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        this.isIdle = true;
        return;
    }

    this.currentInput = { ...input.keys };
    
    const movementVector = input.getMovementVector();
    this.isIdle = movementVector.x === 0 && movementVector.y === 0;

    if (!this.isIdle) {
        const adjustedSpeed = this.speed * deltaTime;
        
        // Calculate velocity based on movement vector
        this.velocity.x = movementVector.x * adjustedSpeed;
        this.velocity.y = movementVector.y * adjustedSpeed;

        // Update direction based on movement
        if (Math.abs(movementVector.x) > Math.abs(movementVector.y)) {
            this.direction = movementVector.x > 0 ? 'right' : 'left';
        } else {
            this.direction = movementVector.y > 0 ? 'down' : 'up';
        }

        // Add to movement buffer
        this.movementBuffer.x += this.velocity.x;
        this.movementBuffer.y += this.velocity.y;

        // Apply whole pixel movements
        const newX = this.x + Math.round(this.movementBuffer.x);
        const newY = this.y + Math.round(this.movementBuffer.y);

        // Clamp to world bounds
        this.x = Math.min(Math.max(newX, 0), worldBounds.width - this.width);
        this.y = Math.min(Math.max(newY, 0), worldBounds.height - this.height);

        // Remove used movement from buffer
        this.movementBuffer.x -= Math.round(this.movementBuffer.x);
        this.movementBuffer.y -= Math.round(this.movementBuffer.y);

        // Update last position
        this.lastX = this.x;
        this.lastY = this.y;
    } else {
        // Reset movement buffer when idle
        this.movementBuffer.x = 0;
        this.movementBuffer.y = 0;
    }
}
}








Suina1.js:
// Suina1.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class Suina1 extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 1.5);
        
        const now = performance.now();
        
        this.moveTimer = now;
        this.changeDirectionInterval = 2500;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = now;

        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.disappearanceTimer = null;
        this.canInteract = false;

        this.isPaused = false;

        if (this.sprites && this.sprites.walking) {
            this.currentSprite = 'walking';
            this.activeSprite = this.sprites.walking;
        }
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible) {
            return;
        }

        const isCollidingNow = this.checkCollision(player);

        // First collision detection
        if (isCollidingNow && !this.isColliding && !this.isDisappearing && !this.disappearanceTimer) {
            // Change sprite and play sound
            if (this.sprites.attack) {
                this.currentSprite = 'attack';
                this.activeSprite = this.sprites.attack;
                this.frame = 0;
            }

            const gameInstance = window.gameInstance;
            if (!this.soundPlayed && gameInstance?.audioManager) {
                gameInstance.audioManager.playSound('suina_sound');
                this.soundPlayed = true;
            }

            this.canInteract = true;

            // Set disappearance timer for 2 seconds
            this.disappearanceTimer = setTimeout(() => {
                this.startDisappearance();
            }, 2000);

            this.isColliding = true;
            this.velocity = { x: 0, y: 0 };
            this.movementBuffer = { x: 0, y: 0 };
            this.isIdle = true;
        }

        // Handle button interactions within the 2-second window
        if (this.canInteract && !this.isDisappearing) {
            const gameInstance = window.gameInstance;
            
            if (input.keys.KeyB) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('professore_smack');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 2);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
            else if (input.keys.KeyF) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('suina_fuck');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 5);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
        }

        // Handle movement if not in collision or disappearing state
        if (!this.isColliding && !this.isDisappearing) {
            const distance = Math.hypot(player.x - this.x, player.y - this.y);
            if (distance < 150) {
                this.runAwayFrom(player, deltaTime, worldBounds);
                this.isIdle = false;
            } else {
                this.moveRandomly(deltaTime, worldBounds);
            }
        }
    }

startDisappearance() {
        console.log('Starting disappearance sequence for Suina1');
        this.isDisappearing = true;
        this.isVisible = false;
        this.canInteract = false;
        
        // Clear any existing timer
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        // Notify level manager about disappearance
        if (this.levelManager) {
            console.log('Notifying LevelManager about Suina1 disappearance');
            this.levelManager.handleCharacterDisappear(this);
        } else {
            console.warn('No levelManager reference found in Suina1');
        }
    }

    respawn() {
        const padding = 100;
        
        // Calculate valid spawn area
        const minX = padding;
        const maxX = CONFIG.WORLD.WIDTH - this.width - padding;
        const minY = padding;
        const maxY = CONFIG.WORLD.HEIGHT - this.height - padding;
        
        // Generate random position within valid bounds
        this.x = Math.floor(minX + Math.random() * (maxX - minX));
        this.y = Math.floor(minY + Math.random() * (maxY - minY));
        
        // Reset all states
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.currentSprite = 'walking';
        this.activeSprite = this.sprites.walking;
        this.canInteract = false;
        
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        // Reset movement parameters
        const now = performance.now();
        this.moveTimer = now;
        this.lastDirectionChange = now;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.isIdle = false;
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        
        // Set random initial direction
        const directions = ['up', 'down', 'left', 'right'];
        this.direction = directions[Math.floor(Math.random() * directions.length)];
        this.lastNonIdleDirection = this.direction;
    }

    cleanup() {
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }
        this.canInteract = false;
        super.cleanup();
    }

  


    resetCollisionState() {
        if (!this.isDisappearing) {
            this.isColliding = false;
            this.soundPlayed = false;
            this.currentSprite = 'walking';
            this.activeSprite = this.sprites.walking;
        }
    }

    handleMovement(player, worldBounds, deltaTime) {
        // Your existing movement code here...
        const currentTime = performance.now();
        const maxDeltaTime = 32;
        const effectiveDeltaTime = Math.min(deltaTime, maxDeltaTime);
        const distance = Math.hypot(player.x - this.x, player.y - this.y);

        if (distance < 150) {
            this.runAwayFrom(player, effectiveDeltaTime, worldBounds);
        } else {
            this.moveRandomly(effectiveDeltaTime, worldBounds);
        }
    }



    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        const adjustedSpeed = this.speed * deltaTime * 1.2;

        const oldX = this.x;
        const oldY = this.y;

        const randomOffset = Math.random() * 0.2 - 0.1;
        const finalAngle = angle + randomOffset;

        this.x = Math.min(Math.max(this.x + Math.cos(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.width - this.width);
        this.y = Math.min(Math.max(this.y + Math.sin(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.height - this.height);

        if (this.x !== oldX || this.y !== oldY) {
            this.updateDirection(this.x - oldX, this.y - oldY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }
    }

    handleCollision(player, input) {
        const gameInstance = window.gameInstance;

        // Initial collision detection
        if (!this.isColliding && !this.isDisappearing && this.isVisible) {
            // Stop all movement and set initial states
            this.isColliding = true;
            this.velocity = { x: 0, y: 0 };
            this.movementBuffer = { x: 0, y: 0 };
            this.isIdle = true;
            this.buttonInteractionAvailable = true;

            // Play sound once
            if (!this.soundPlayed && gameInstance.audioManager) {
                gameInstance.audioManager.playSound('suina_sound');
                this.soundPlayed = true;
            }

            // Change to attack sprite
            if (this.sprites.attack) {
                this.currentSprite = 'attack';
                this.activeSprite = this.sprites.attack;
                this.frame = 0;
            }
        }

        // Handle button interactions
        if (this.buttonInteractionAvailable) {
            if (input.keys.KeyB || input.keys.KeyF) {
                if (input.keys.KeyB && gameInstance.audioManager) {
                    gameInstance.audioManager.playSound('professore_smack');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 2);
                    }
                } else if (input.keys.KeyF && gameInstance.audioManager) {
                    gameInstance.audioManager.playSound('suina_fuck');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 5);
                    }
                }

                if (this.sprites.attack) {
                    this.currentSprite = 'attack';
                    this.activeSprite = this.sprites.attack;
                    this.frame = 0;
                }

                this.hasInteracted = true;
                this.buttonInteractionAvailable = false;
                this.startDisappearance();
            }
        }
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const oldX = this.x;
        const oldY = this.y;

        switch (this.direction) {
            case 'up':
                this.y = Math.max(this.y - adjustedSpeed, 0);
                break;
            case 'down':
                this.y = Math.min(this.y + adjustedSpeed, worldBounds.height - this.height);
                break;
            case 'left':
                this.x = Math.max(this.x - adjustedSpeed, 0);
                break;
            case 'right':
                this.x = Math.min(this.x + adjustedSpeed, worldBounds.width - this.width);
                break;
        }

        const moved = (Math.abs(this.x - oldX) > 0.01 || Math.abs(this.y - oldY) > 0.01);

        if (moved) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
            this.stuckTimer = 0;
        } else {
            this.stuckTimer += deltaTime * 16.67;
        }

        return moved;
    }

    randomizeDirection(worldBounds) {
        const { width, height } = worldBounds;
        const edgeBuffer = 50;
        const cornerBuffer = 100;
        
        const nearLeft = this.x < edgeBuffer;
        const nearRight = this.x > width - this.width - edgeBuffer;
        const nearTop = this.y < edgeBuffer;
        const nearBottom = this.y > height - this.height - edgeBuffer;

        let directions = ['up', 'down', 'left', 'right'];

        if (this.directionChangeCount < 3) {
            if (!nearLeft && !nearRight && !nearTop && !nearBottom) {
                if (Math.random() < 0.7) {
                    return;
                }
            }
        }

        // Filter out directions based on position
        if (nearLeft) directions = directions.filter(d => d !== 'left');
        if (nearRight) directions = directions.filter(d => d !== 'right');
        if (nearTop) directions = directions.filter(d => d !== 'up');
        if (nearBottom) directions = directions.filter(d => d !== 'down');

        // Special handling for corners
        if (this.x < cornerBuffer && this.y < cornerBuffer) {
            directions = ['right', 'down'];
        } else if (this.x > width - cornerBuffer && this.y < cornerBuffer) {
            directions = ['left', 'down'];
        } else if (this.x < cornerBuffer && this.y > height - cornerBuffer) {
            directions = ['right', 'up'];
        } else if (this.x > width - cornerBuffer && this.y > height - cornerBuffer) {
            directions = ['left', 'up'];
        }

        if (directions.length === 0) {
            directions = ['up', 'down', 'left', 'right'];
        }

        const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };
        if (this.direction && this.directionChangeCount < 2) {
            directions = directions.filter(d => d !== opposites[this.direction]);
        }

        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
        this.directionChangeCount++;
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }

    cleanup() {
        super.cleanup();
        
        if (!this.isDisappearing) {
            this.isColliding = false;
            this.buttonInteractionAvailable = false;
            this.soundPlayed = false;
            this.currentSprite = null;
            this.activeSprite = null;
            this.hasInteracted = false;
        }
    }

    pauseUpdates() {
        super.pauseUpdates();
    }

    resumeUpdates() {
        super.resumeUpdates();
        this.moveTimer = performance.now();
        this.lastDirectionChange = performance.now();
        this.lastUpdateTime = performance.now();
        this.frameTime = performance.now();
    }
}










Suina2.js:
// Suina2.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class Suina2 extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 1.5);
        
        const now = performance.now();
        
        this.moveTimer = now;
        this.changeDirectionInterval = 2500;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = now;

        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.disappearanceTimer = null;
        this.canInteract = false;
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible) {
            return;
        }

        const isCollidingNow = this.checkCollision(player);

        // First collision detection


    if (isCollidingNow && !this.isColliding && !this.isDisappearing && !this.disappearanceTimer) {
        // Change to suina1-attack.png sprite
        if (this.sprites.attack) {
            this.currentSprite = 'attack';
            this.activeSprite = this.sprites.attack;  // This will be suina1-attack.png
            this.frame = 0;
        }

        const gameInstance = window.gameInstance;
        if (!this.soundPlayed && gameInstance?.audioManager) {
            gameInstance.audioManager.playSound('suina_sound');
            this.soundPlayed = true;
        }

        this.canInteract = true;

        // Set disappearance timer for 2 seconds
        this.disappearanceTimer = setTimeout(() => {
            this.startDisappearance();
        }, 2000);

        this.isColliding = true;
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        this.isIdle = true;
    }


        // Handle button interactions within the 2-second window
        if (this.canInteract && !this.isDisappearing) {
            const gameInstance = window.gameInstance;
            
            if (input.keys.KeyB) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('professore_smack');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 3);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
            else if (input.keys.KeyF) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('suina_fuck');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 6);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
        }

        // Handle movement if not in collision or disappearing state
        if (!this.isColliding && !this.isDisappearing) {
            const distance = Math.hypot(player.x - this.x, player.y - this.y);
            if (distance < 150) {
                this.runAwayFrom(player, deltaTime, worldBounds);
                this.isIdle = false;
            } else {
                this.moveRandomly(deltaTime, worldBounds);
            }
        }
    }

    startDisappearance() {
        this.isDisappearing = true;
        this.isVisible = false;
        this.canInteract = false;
        
        // Clear any existing timer
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        if (this.levelManager) {
            this.levelManager.handleCharacterDisappear(this);
        }
    }

    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        const adjustedSpeed = this.speed * deltaTime * 1.2;

        const oldX = this.x;
        const oldY = this.y;

        const randomOffset = Math.random() * 0.2 - 0.1;
        const finalAngle = angle + randomOffset;

        this.x = Math.min(Math.max(this.x + Math.cos(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.width - this.width);
        this.y = Math.min(Math.max(this.y + Math.sin(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.height - this.height);

        if (this.x !== oldX || this.y !== oldY) {
            this.updateDirection(this.x - oldX, this.y - oldY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const oldX = this.x;
        const oldY = this.y;

        switch (this.direction) {
            case 'up':
                this.y = Math.max(this.y - adjustedSpeed, 0);
                break;
            case 'down':
                this.y = Math.min(this.y + adjustedSpeed, worldBounds.height - this.height);
                break;
            case 'left':
                this.x = Math.max(this.x - adjustedSpeed, 0);
                break;
            case 'right':
                this.x = Math.min(this.x + adjustedSpeed, worldBounds.width - this.width);
                break;
        }

        const moved = (Math.abs(this.x - oldX) > 0.01 || Math.abs(this.y - oldY) > 0.01);

        if (moved) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
            this.stuckTimer = 0;
        } else {
            this.stuckTimer += deltaTime * 16.67;
            if (this.stuckTimer > 1000) {
                this.randomizeDirection(worldBounds);
                this.stuckTimer = 0;
            }
        }
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }

    randomizeDirection(worldBounds) {
        const directions = ['up', 'down', 'left', 'right'];
        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
    }

    cleanup() {
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }
        this.canInteract = false;
        super.cleanup();
    }
}











SuinaEvil.js:
// SuinaEvil.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class SuinaEvil extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 1.5);
        
        const now = performance.now();
        
        // Movement related properties
        this.moveTimer = now;
        this.changeDirectionInterval = 2500;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = now;

        // Animation and state properties
        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        this.currentSprite = 'walking';
        this.activeSprite = sprites?.walking;
        
        // Interaction states
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.canInteract = false;
        this.isGameOverTriggered = false;

        // Timers
        this.disappearanceTimer = null;
        this.interactionCooldown = null;
        this.gameOverAnimationInProgress = false;
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible || this.gameOverAnimationInProgress) {
            return;
        }

        const isCollidingNow = this.checkCollision(player);

        // First collision detection
        if (isCollidingNow && !this.isColliding && !this.isDisappearing) {
            this.handleInitialCollision();
        }

        // Handle button interactions
        if (this.canInteract && !this.isDisappearing) {
            this.handleInteraction(input, player);
        }

        // Handle movement if not in collision or disappearing state
        if (!this.isColliding && !this.isDisappearing) {
            this.handleMovement(player, deltaTime, worldBounds);
        }
    }

    handleInitialCollision() {
        // Change to attack sprite
        if (this.sprites.attack) {
            this.currentSprite = 'attack';
            this.activeSprite = this.sprites.attack;
            this.frame = 0;
        }

        // Play initial collision sound
        const gameInstance = window.gameInstance;
        if (!this.soundPlayed && gameInstance?.audioManager) {
            gameInstance.audioManager.playSound('suina_sound');
            this.soundPlayed = true;
        }

        // Set up interaction window
        this.canInteract = true;
        this.isColliding = true;
        
        // Reset movement
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        this.isIdle = true;

        // Set disappearance timer
        this.disappearanceTimer = setTimeout(() => {
            this.startDisappearance();
        }, 2000);
    }


handleInteraction(input, player) {
    const gameInstance = window.gameInstance;
    
    if (input.keys.KeyB) {
        if (gameInstance?.audioManager) {
            console.log('buzz');
            gameInstance.audioManager.playSound('buzz');

            if (gameInstance.scoreManager) {
                // Use the centralized message system
                if (gameInstance.renderer) {
                    gameInstance.renderer.showSuinaMalaMessage();
                }
                gameInstance.scoreManager.increaseScore('love', -5);
                gameInstance.scoreManager.scoreAnimation.addAnimation(5, true);
		gameInstance.scoreManager.increaseScore('energy', -20);
            }
        }

        this.triggerDisappearance();
    }
    else if (input.keys.KeyF && !this.isGameOverTriggered) {
        this.triggerGameOver(player);
    }
}

triggerGameOver(player) {
    const gameInstance = window.gameInstance;
    if (!gameInstance) return;

    this.isGameOverTriggered = true;
    this.gameOverAnimationInProgress = true;

    // Play evil sound effect
    if (gameInstance.audioManager) {
        gameInstance.audioManager.playSound('buzz');  // Added buzz sound back
        gameInstance.audioManager.playSound('suina_evil');
    }

    // Trigger game over sequence
    if (gameInstance.gameState) {
        gameInstance.gameState.triggerJailGameOver(player);
    }

    // Show game over message sequence
    if (gameInstance.renderer) {
        gameInstance.renderer.showGameOverMessage();
    }

    // Clean up interaction state
    this.canInteract = false;
    if (this.disappearanceTimer) {
        clearTimeout(this.disappearanceTimer);
    }

    // Start disappearance after game over animation
    setTimeout(() => {
        this.gameOverAnimationInProgress = false;
        this.startDisappearance();
    }, 2000);
}




    triggerDisappearance() {
        this.canInteract = false;
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
        }
        this.startDisappearance();
    }

    startDisappearance() {
        if (this.isDisappearing) return;
        
        this.isDisappearing = true;
        this.isVisible = false;
        this.canInteract = false;
        
        // Clear any existing timer
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        // Notify level manager
        if (this.levelManager) {
            this.levelManager.handleCharacterDisappear(this);
        }
    }

    handleMovement(player, deltaTime, worldBounds) {
        const distance = Math.hypot(player.x - this.x, player.y - this.y);
        if (distance < 150) {
            this.runAwayFrom(player, deltaTime, worldBounds);
            this.isIdle = false;
        } else {
            this.moveRandomly(deltaTime, worldBounds);
        }
    }

    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        const adjustedSpeed = this.speed * deltaTime * 1.2;

        const oldX = this.x;
        const oldY = this.y;

        const randomOffset = Math.random() * 0.2 - 0.1;
        const finalAngle = angle + randomOffset;

        this.x = Math.min(Math.max(this.x + Math.cos(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.width - this.width);
        this.y = Math.min(Math.max(this.y + Math.sin(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.height - this.height);

        if (this.x !== oldX || this.y !== oldY) {
            this.updateDirection(this.x - oldX, this.y - oldY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const oldX = this.x;
        const oldY = this.y;

        switch (this.direction) {
            case 'up':
                this.y = Math.max(this.y - adjustedSpeed, 0);
                break;
            case 'down':
                this.y = Math.min(this.y + adjustedSpeed, worldBounds.height - this.height);
                break;
            case 'left':
                this.x = Math.max(this.x - adjustedSpeed, 0);
                break;
            case 'right':
                this.x = Math.min(this.x + adjustedSpeed, worldBounds.width - this.width);
                break;
        }

        const moved = (Math.abs(this.x - oldX) > 0.01 || Math.abs(this.y - oldY) > 0.01);

        if (moved) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
            this.stuckTimer = 0;
        } else {
            this.stuckTimer += deltaTime * 16.67;
            if (this.stuckTimer > 1000) {
                this.randomizeDirection(worldBounds);
                this.stuckTimer = 0;
            }
        }
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }

    randomizeDirection(worldBounds) {
        const directions = ['up', 'down', 'left', 'right'];
        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
    }

    cleanup() {
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }
        if (this.interactionCooldown) {
            clearTimeout(this.interactionCooldown);
            this.interactionCooldown = null;
        }
        this.canInteract = false;
        this.isGameOverTriggered = false;
        this.gameOverAnimationInProgress = false;
        super.cleanup();
    }
}














Diego.js:
// Diego.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class Diego extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        // Using fast speed multiplier similar to Walter
        super(x, y, width, height, sprites, type, 1.1);
        
        const now = performance.now();
        
        // Initialize timers and movement variables (following Walter's pattern)
        this.moveTimer = now;
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.lastDirectionChange = now;
        this.lastZigzag = now;
        this.zigzagDirection = 1;

        // State variables
        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        
        this.isColliding = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.energyTaken = false;
        this.lastEnergyTime = now;
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible) return;

        const isCollidingNow = this.checkCollision(player);
        const currentTime = performance.now();

        // Handle collision with player
        if (isCollidingNow && !this.isColliding) {
            const gameInstance = window.gameInstance;
            
            // Check cooldown (5 seconds like Walter)
            if (!this.energyTaken || (currentTime - this.lastEnergyTime > 5000)) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('drink');
                }
                
                // Only decrease energy, removed friendship increase
                if (gameInstance?.scoreManager) {
                    gameInstance.scoreManager.increaseScore('energy', -10);
                    gameInstance.scoreManager.scoreAnimation.addAnimation(10, true);
                }
                
                this.energyTaken = true;
                this.lastEnergyTime = currentTime;
            }
            
            this.isColliding = true;
            this.soundPlayed = true;
        }

        // Reset collision state when not colliding
        if (!isCollidingNow && this.isColliding) {
            this.isColliding = false;
            this.soundPlayed = false;
            this.energyTaken = false;
        }

        // Chase player with unpredictable movement
        if (!this.isColliding) {
            this.chasePlayer(player, deltaTime, worldBounds);
            this.isIdle = false;
        }
    }

    chasePlayer(player, deltaTime, worldBounds) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const angle = Math.atan2(dy, dx);
        
        const adjustedSpeed = this.speed * deltaTime * 1.8;

        const currentTime = performance.now();

        // Base chase angle
        let moveAngle = angle;

        // Add unpredictable zigzag movement (similar to Walter's pattern)
        const timeSinceLastZigzag = currentTime - this.lastZigzag;
        const shouldZigzag = timeSinceLastZigzag > 400 && Math.random() < 0.5;

        if (shouldZigzag) {
            this.lastZigzag = currentTime;
            this.zigzagDirection *= -1;
            moveAngle += (Math.PI / 4) * this.zigzagDirection;
        } else if (timeSinceLastZigzag < 200) {
            moveAngle += (Math.PI / 4) * this.zigzagDirection;
        }

        // Calculate new position
        const newX = this.x + Math.cos(moveAngle) * adjustedSpeed;
        const newY = this.y + Math.sin(moveAngle) * adjustedSpeed;

        // Apply movement with world bounds check
        this.x = Math.min(Math.max(newX, 0), worldBounds.width - this.width);
        this.y = Math.min(Math.max(newY, 0), worldBounds.height - this.height);

        // Update direction based on movement
        const actualDX = this.x - this.lastX;
        const actualDY = this.y - this.lastY;
        if (Math.abs(actualDX) > 0.5 || Math.abs(actualDY) > 0.5) {
            this.updateDirection(actualDX, actualDY);
        }

        this.lastX = this.x;
        this.lastY = this.y;
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
    }

    cleanup() {
        this.isColliding = false;
        this.soundPlayed = false;
        this.energyTaken = false;
        this.lastEnergyTime = performance.now();
        super.cleanup();
    }
}





Milly.js:
// Milly.js
import { BaseCharacter } from './BaseCharacter.js';

export class Milly extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
        this.lastBehaviorUpdate = performance.now();
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused) return;
        
        const currentTime = performance.now();
        this.lastBehaviorUpdate = currentTime;
        
        // Currently remains idle - future behavior can be added here
        this.isIdle = true;
        this.direction = 'down';
    }
}











Walter.js:
// Walter.js
import { BaseCharacter } from './BaseCharacter.js';

export class Walter extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 3.0);
        
        const now = performance.now();
        
        this.moveTimer = now;
        this.changeDirectionInterval = 1200;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = now;
        this.lastZigzag = now;
        this.zigzagDirection = 1;

        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        
        this.isColliding = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.energyGiven = false;
        this.lastEnergyTime = now;
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible) return;

        const isCollidingNow = this.checkCollision(player);
        const currentTime = performance.now();

        // Handle initial collision
        if (isCollidingNow && !this.isColliding) {
            const gameInstance = window.gameInstance;
            
            // Check if enough time has passed since last energy given (5 seconds cooldown)
            if (!this.energyGiven || (currentTime - this.lastEnergyTime > 5000)) {
                // Play sound
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('walter_sound');
                }
                
                // Increase energy score directly through scoreManager
                if (gameInstance?.scoreManager) {
                    const currentEnergy = gameInstance.scoreManager.scores.energy;
                    gameInstance.scoreManager.scores.energy = Math.min(100, currentEnergy + 30);
                    // Add animation for energy increase
                    gameInstance.scoreManager.scoreAnimation.addAnimation(30);
                }
                
                this.energyGiven = true;
                this.lastEnergyTime = currentTime;
            }
            
            this.isColliding = true;
            this.soundPlayed = true;
        }

        // Reset collision state when not colliding
        if (!isCollidingNow && this.isColliding) {
            this.isColliding = false;
            this.soundPlayed = false;
            this.resetMovement();
        }

        // Continue with movement
        if (!this.isColliding) {
            const distance = Math.hypot(player.x - this.x, player.y - this.y);
            if (distance < 200) {
                this.runAwayFrom(player, deltaTime, worldBounds);
                this.isIdle = false;
            } else {
                this.moveRandomly(deltaTime, worldBounds);
            }
        }
    }

    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        
        const distance = Math.hypot(dx, dy);
        const speedMultiplier = distance < 100 ? 2.2 : 1.8;
        const adjustedSpeed = this.speed * deltaTime * speedMultiplier;

        const cornerBuffer = 50;
        const nearLeftWall = this.x < cornerBuffer;
        const nearRightWall = this.x > worldBounds.width - cornerBuffer;
        const nearTopWall = this.y < cornerBuffer;
        const nearBottomWall = this.y > worldBounds.height - cornerBuffer;

        let newX = this.x;
        let newY = this.y;

        const inCorner = (nearLeftWall && nearTopWall) || 
                        (nearLeftWall && nearBottomWall) ||
                        (nearRightWall && nearTopWall) ||
                        (nearRightWall && nearBottomWall);

        const currentTime = performance.now();

        // Base escape angle calculation
        let moveAngle = angle;

        // Add randomization to the base angle for unpredictability
        const randomAngleOffset = (Math.random() - 0.5) * (Math.PI / 6); // ±30 degrees
        moveAngle += randomAngleOffset;

        // Zigzag logic with increased frequency
        const timeSinceLastZigzag = currentTime - this.lastZigzag;
        const shouldStartNewZigzag = timeSinceLastZigzag > 600 && Math.random() < 0.4;

        if (shouldStartNewZigzag) {
            this.lastZigzag = currentTime;
            this.zigzagDirection *= -1;
            moveAngle += (Math.PI / 3) * this.zigzagDirection;
        } else if (timeSinceLastZigzag < 300) {
            moveAngle += (Math.PI / 3) * this.zigzagDirection;
        }

        if (inCorner) {
            const centerX = worldBounds.width / 2;
            const centerY = worldBounds.height / 2;
            moveAngle = Math.atan2(centerY - this.y, centerX - this.x);
        }

        newX = this.x + Math.cos(moveAngle) * adjustedSpeed;
        newY = this.y + Math.sin(moveAngle) * adjustedSpeed;

        const edgeBuffer = 30;
        if (this.x < edgeBuffer) newX += adjustedSpeed;
        if (this.x > worldBounds.width - edgeBuffer) newX -= adjustedSpeed;
        if (this.y < edgeBuffer) newY += adjustedSpeed;
        if (this.y > worldBounds.height - edgeBuffer) newY -= adjustedSpeed;

        this.x = Math.min(Math.max(newX, 20), worldBounds.width - 20);
        this.y = Math.min(Math.max(newY, 20), worldBounds.height - 20);

        const actualDX = this.x - this.lastX;
        const actualDY = this.y - this.lastY;
        if (Math.abs(actualDX) > 0.5 || Math.abs(actualDY) > 0.5) {
            this.updateDirection(actualDX, actualDY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }

        this.lastX = this.x;
        this.lastY = this.y;
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const cornerBuffer = 50;
        const oldX = this.x;
        const oldY = this.y;

        let newX = this.x;
        let newY = this.y;

        const now = performance.now();
        if (now - this.lastDirectionChange > 1500) {
            this.randomizeDirection(worldBounds);
            this.lastDirectionChange = now;
        }

        switch (this.direction) {
            case 'up':
                newY = this.y - adjustedSpeed;
                break;
            case 'down':
                newY = this.y + adjustedSpeed;
                break;
            case 'left':
                newX = this.x - adjustedSpeed;
                break;
            case 'right':
                newX = this.x + adjustedSpeed;
                break;
        }

        this.x = Math.min(Math.max(newX, cornerBuffer), worldBounds.width - cornerBuffer);
        this.y = Math.min(Math.max(newY, cornerBuffer), worldBounds.height - cornerBuffer);

        if (Math.abs(this.x - oldX) > 0.1 || Math.abs(this.y - oldY) > 0.1) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
        }
    }

    resetMovement() {
        this.direction = this.lastNonIdleDirection;
        this.stuckTimer = 0;
        this.isIdle = false;
    }

    updateDirection(dx, dy) {
        const minThreshold = 0.5;
        
        if (Math.abs(dx) < minThreshold && Math.abs(dy) < minThreshold) {
            return;
        }

        if (Math.abs(dx) > Math.abs(dy) * 1.5) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else if (Math.abs(dy) > Math.abs(dx) * 1.5) {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }

    randomizeDirection(worldBounds) {
        const directions = ['up', 'down', 'left', 'right'];
        const currentIndex = directions.indexOf(this.direction);
        
        if (currentIndex !== -1) {
            directions.splice(currentIndex, 1);
            const oppositeIndex = (currentIndex + 2) % 4;
            if (oppositeIndex < directions.length) {
                directions.splice(oppositeIndex, 1);
            }
        }
        
        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
    }

    cleanup() {
        this.isColliding = false;
        this.soundPlayed = false;
        this.energyGiven = false;
        this.lastEnergyTime = performance.now();
        super.cleanup();
    }
}
