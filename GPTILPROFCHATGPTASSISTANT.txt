

>>>>>tell me if you find bugs or discrepancies or inconsistency <<<<<<




Coding a videogame in javascript, html5 and css: find below in text the tree structure (TREEilprofessore) and I attached to this chat all the modules that compose a videogame called "IL PROFESSORE" is an action adventure with elements of top-down puzzle platformer. "Il Professore" is the protagonist of the game. "Il Professore" Is a Player Character in the style of Mario bros. 
Consider that the createCharacter method is designed to allow for progressive activation of characters. As new functionality are implemented for more characters, their types will be added to the activeCharacters.

Please only answer with effective solutions assuming that all the assests are in place in the right directories. There is no need to verify that the code is correctly defined as the code I gave to you is at is it. 
Only focus on the code logic and find the cause that is generating the error then give the solutions, always use the assumptions below:
 
Claude, you are a javascripit master helping me coding and you always follow the rules:
1. Assume All Provided Code is Correct and Present
You will focus solely on logical flow and interactions between the code components without redundantly suggesting corrections to lines or assets I have already confirmed.

2. Focus on Logical Causes Only
You will analyze the problem based on the symptoms (like your error logs or outputs) and provide targeted suggestions for the root cause without assuming missing assets or functionality.

3. Skip Verifications Unless I Request Them
You will avoid generic debugging suggestions (like verifying asset directories or sprite mappings) unless the issue specifically points to those.

4. Consolidate Steps into Clear, Minimal Actions
You'll ensure my responses are precise, avoiding redundant or unnecessary steps, and focus on changes or analysis directly tied to the problem.

5. Every time you write a code for me you rewrite the complete module with the fixes and the updated modifications. Always remember to put on the top of the code as a label the name of the original Module (ie LevelManager.js or main.js or AssetLoader.js etc.)

6. If you're unsure about something, it's okay to admit it. Just say you don’t know.

Don't do anything, just analyze all the files, understand the game and its structure and wait for my next request, answer OK




TREEilprofessore:
Ilprofessore
│   config.js
│   index.html
│   main.js
│
├───assets
│   ├───maps
│   │       level1.json
│   │
│   ├───sounds
│   │       diego-sound.mp3
│   │       drink.mp3
│   │       milly-sound.mp3
│   │       prof-fuck.mp3
│   │       prof-punch.mp3
│   │       prof-smack.mp3
│   │       buzz.mp3
│   │       prof-step.mp3
│   │       prof-theme.mp3
│   │       suina-evil.mp3
│   │       suina-fuck.mp3
│   │       suina-sound.mp3
│   │       suina-walk.mp3
│   │       urlo.mp3
│   │       walter-sound.mp3
│   │       walter-welcome.mp3
│   │
│   └───sprites
│       │   background.png
│       │   background2.png
│       │   background3.png
│       │   background4.png
│       │   background5.png
│       │   fallback-background.png
│       │   fallback-idle.png
│       │   fallback-spritesheet.png
│       │   jail.png
│       │   professore-idle.png
│       │   professore-spritesheet.png
│       │   skull.png
│       │   skull1.png
│       │
│       ├───diego
│       │       diego-attack.png
│       │       diego-idle.png
│       │       diego-spritesheet.png
│       │
│       ├───milly
│       │       milly-idle.png
│       │       milly-interact.png
│       │       milly-spritesheet.png
│       │
│       ├───professore
│       │       professore-idle.png
│       │       professore-spritesheet.png
│       │
│       ├───suina1
│       │       suina1-attack.png
│       │       suina1-idle.png
│       │       suina1-spritesheet.png
│       │       suina1RED-spritesheet.png
│       │
│       ├───suina2
│       │       suina2-attack.png
│       │       suina2-idle.png
│       │       suina2-spritesheet.png
│       │       suina2BLUE-spritesheet.png
│       │
│       ├───suinaEvil
│       │       suinaevil-attack.png
│       │       suinaevil-idle.png
│       │       suinaevil-spritesheet.png
│       │
│       └───walter
│               walter-attack.png
│               walter-idle.png
│               walter-spritesheet.png
│
├───characters
│       BaseCharacter.js
│       Diego.js
│       Milly.js
│       Player.js
│       Suina1.js
│       Suina2.js
│       SuinaEvil.js
│       Walter.js
│
├───js
│   └───engine
│           AudioManager.js
│           Camera.js
│           GameStateManager.js
│           Input.js
│           Renderer.js
│           ScoreAnimation.js
│           ScoreManager.js
│
├───levels
│       LevelManager.js
│
├───styles
│       style.css
│
└───utils
        AssetLoader.js
        CharacterRegistry.js




------------------



// main.js
// main.js
import { CONFIG } from './config.js';
import { Camera } from './js/engine/Camera.js';
import { InputHandler } from './js/engine/Input.js';
import { Player } from './characters/Player.js';
import { Renderer } from './js/engine/Renderer.js';
import { AssetLoader } from './utils/AssetLoader.js';
import { AudioManager } from './js/engine/AudioManager.js';
import { LevelManager } from './levels/LevelManager.js';
import { ScoreManager } from './js/engine/ScoreManager.js';
import { GameStateManager } from './js/engine/GameStateManager.js';

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Core systems initialization with verified state
        this.initializationState = {
            audio: false,
            assets: false,
            player: false,
            levelManager: false,
            renderer: false
        };

        // Core components (initially null)
        this.camera = null;
        this.input = null;
        this.audioManager = null;
        this.scoreManager = null;
        this.gameState = null;
        this.renderer = null;
        this.levelManager = null;
        this.player = null;
        
        // Make game instance globally available immediately
        window.gameInstance = this;
        
        // Initialize core systems
        this.setupCoreSystems();
        
        // State tracking
        this.initialized = false;
        this.assetsLoaded = false;
        
        // Performance monitoring
        this.lastUpdateTime = performance.now();
        this.frameCount = 0;
        this.fps = 0;
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = performance.now();
    }

    setupCoreSystems() {
        // Initialize core components
        this.camera = new Camera(CONFIG.CANVAS.DEFAULT_WIDTH, CONFIG.CANVAS.DEFAULT_HEIGHT);
        this.input = new InputHandler();
        this.audioManager = new AudioManager();
        this.scoreManager = new ScoreManager(this.ctx);
        this.gameState = new GameStateManager(this);

        // Set up canvas and event listeners
        this.setupCanvas();
        window.addEventListener('resize', () => this.setupCanvas());
    }

    setupCanvas() {
        const isMobile = window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT;
        
        if (isMobile) {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
        } else {
            this.canvas.width = CONFIG.CANVAS.DEFAULT_WIDTH;
            this.canvas.height = CONFIG.CANVAS.DEFAULT_HEIGHT;
            this.canvas.style.width = `${CONFIG.CANVAS.DEFAULT_WIDTH}px`;
            this.canvas.style.height = `${CONFIG.CANVAS.DEFAULT_HEIGHT}px`;
            this.canvas.style.position = 'absolute';
            this.canvas.style.top = '50%';
            this.canvas.style.left = '50%';
            this.canvas.style.transform = 'translate(-50%, -50%)';
        }
        
        if (this.camera) {
            this.camera.width = this.canvas.width;
            this.camera.height = this.canvas.height;
        }
    }

    async initAudio() {
        try {
            console.log('Initializing audio system...');
            await this.audioManager.init();
            this.initializationState.audio = true;
            console.log('Audio system initialized successfully');
        } catch (error) {
            console.error('Audio initialization failed:', error);
            this.initializationState.audio = false;
            throw new Error('Audio initialization failed');
        }
    }

    async loadGameAssets() {
        try {
            console.log('Loading game assets...');
            const assets = await AssetLoader.loadAssets();
            this.assets = assets;
            this.assetsLoaded = true;
            this.initializationState.assets = true;
            console.log('Game assets loaded successfully');
            return assets;
        } catch (error) {
            console.error('Asset loading failed:', error);
            this.initializationState.assets = false;
            throw new Error('Asset loading failed');
        }
    }

    async init() {
        if (this.initialized) {
            console.warn('Game already initialized');
            return;
        }

        try {
            console.log('Starting game initialization sequence...');

            // Step 1: Initialize audio system
            await this.initAudio();
            
            // Verify audio initialization
            if (!this.audioManager.initialized) {
                throw new Error('Audio system failed to initialize properly');
            }

            // Step 2: Load game assets
            const assets = await this.loadGameAssets();
            
            // Step 3: Initialize player
            this.player = new Player(
                CONFIG.WORLD.WIDTH / 2,
                CONFIG.WORLD.HEIGHT / 2,
                CONFIG.PLAYER.WIDTH,
                CONFIG.PLAYER.HEIGHT,
                assets.sprites.professore,
                'professore'
            );
            this.initializationState.player = true;

            // Step 4: Initialize game systems
            console.log('Initializing game systems...');
            this.levelManager = new LevelManager(assets, this.gameState);
            this.initializationState.levelManager = true;

            this.renderer = new Renderer(this.ctx, this.levelManager, this.gameState);
            this.initializationState.renderer = true;
            
            // Store renderer reference in gameState
            this.gameState.renderer = this.renderer;

            // Step 5: Load initial level
            console.log('Loading initial level...');
            await this.levelManager.loadLevel(1, this.player);

            // Verify all systems
            if (this.verifyInitialization()) {
                this.initialized = true;
                console.log('Game initialization complete');
                this.startGameLoop();
            } else {
                throw new Error('System verification failed');
            }

        } catch (error) {
            console.error('Game initialization failed:', error);
            this.handleInitializationError(error);
            throw error;
        }
    }

    verifyInitialization() {
        const failed = Object.entries(this.initializationState)
            .filter(([, value]) => !value)
            .map(([key]) => key);

        if (failed.length > 0) {
            console.error('Initialization failed for:', failed);
            return false;
        }

        return true;
    }

    handleInitializationError(error) {
        // Display error message to user
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'white';
        this.ctx.font = '20px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('Failed to start game. Please refresh the page.', 
            this.canvas.width / 2, this.canvas.height / 2);
    }

    startGameLoop() {
        console.log('Starting game loop');
        this.lastUpdateTime = performance.now();
        this.gameLoop();
    }

    update() {
        if (!this.initialized || this.gameState.isGameOver) return;

        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastUpdateTime) / 16.67;
        this.lastUpdateTime = currentTime;

        // Update player
        this.player.update(this.input, {
            width: CONFIG.WORLD.WIDTH,
            height: CONFIG.WORLD.HEIGHT
        });

        // Update level and characters
        this.levelManager.update(
            this.player,
            {
                width: CONFIG.WORLD.WIDTH,
                height: CONFIG.WORLD.HEIGHT
            },
            this.input
        );

        // Check level transitions
        if (this.levelManager.checkLevelTransition(this.player)) {
            console.log(`Transitioned to Level ${this.levelManager.currentLevel}`);
        }

        // Update camera and audio
        this.camera.follow(this.player, CONFIG.WORLD.WIDTH, CONFIG.WORLD.HEIGHT);
        this.audioManager.handleFootsteps(this.player, !this.player.isIdle);
    }

    draw() {
        if (!this.initialized) return;
        
        // Use consolidated rendering approach
        this.renderer.draw(this.player, this.assets.sprites, this.camera);
        
        // Draw score
        this.scoreManager.draw();

        // Update and draw FPS if in debug mode
        if (CONFIG.DEBUG) {
            this.updateFPS();
            this.drawFPS();
        }
    }

    updateFPS() {
        const now = performance.now();
        this.frameCount++;

        if (now - this.lastFpsUpdate >= this.fpsUpdateInterval) {
            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
            this.frameCount = 0;
            this.lastFpsUpdate = now;
        }
    }

    drawFPS() {
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px Arial';
        this.ctx.fillText(`FPS: ${this.fps}`, 10, 20);
    }

    gameLoop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
}

// Game startup
const startGame = async () => {
    try {
        console.log('Creating game instance...');
        const game = new Game();
        await game.init();
        console.log('Game started successfully');
    } catch (error) {
        console.error('Failed to start game:', error);
    }
};

startGame();










index.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Il Professore Game</title>
  <link rel="stylesheet" href="./styles/style.css">
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
	<button id="back-button" type="button">Exit</button>
  <div id="controls-container">
    <div id="controls">
      <div class="action-buttons">
        <button type="button" id="bacio" class="action-btn left">B</button>
        <button type="button" id="fuck" class="action-btn right">F</button>
      </div>
      <div class="direction-buttons">
        <button type="button" id="left">←</button>
        <button type="button" id="up">↑</button>
        <button type="button" id="down">↓</button>
        <button type="button" id="right">→</button>
      </div>
    </div>
  </div>
  <script src="./main.js" type="module"></script>
</body>
</html>






config.sys:
// config.js
export const CONFIG = {
    CANVAS: {
        DEFAULT_WIDTH: 800,
        DEFAULT_HEIGHT: 600,
        MOBILE_BREAKPOINT: 768
    },
    WORLD: {
        WIDTH: 800,
        HEIGHT: 600
    },
    PLAYER: {
        WIDTH: 68,
        HEIGHT: 68,
        SPEED: 1,
        TOTAL_FRAMES: 4,
        FRAME_DELAY: 4,
        SPEED_MULTIPLIERS: {
            DESKTOP: 1.0,
            MOBILE: 2.0,
            TABLET: 0.85
        }
    },
    AUDIO: {
        MUSIC_VOLUME: 0.1,
        SFX_VOLUME: 0.3,
        FOOTSTEP_INTERVAL: 300
    },
    LEVELS: {
        1: {
            name: 'StartingLevel',
            backgroundKey: 'background1',
            transitions: {
                TEATRO: { x: { min: 0, max: 150 }, y: { min: 0, max: 100 }, nextLevel: 2 },
                MALAFAMA: { x: { min: 550, max: 800 }, y: { min: 0, max: 100 }, nextLevel: 3 },
                GUSTO: { x: { min: 0, max: 150 }, y: { min: 400, max: 600 }, nextLevel: 4 },
                CHESTER: { x: { min: 600, max: 800 }, y: { min: 450, max: 600 }, nextLevel: 5 }
            }
        },
        2: { name: 'Teatro', backgroundKey: 'background2' },
        3: { name: 'Malafama', backgroundKey: 'background3' },
        4: { name: 'Gusto', backgroundKey: 'background4' },
        5: { name: 'Chester', backgroundKey: 'background5' }
    }
};












assetLoader.js:
// AssetLoader.js
// AssetLoader.js
export class AssetLoader {
    static async loadImage(src, fallbackSrc = null) {
        const img = new Image();
        img.src = src;
        return new Promise((resolve, reject) => {
            img.onload = () => resolve(img);
            img.onerror = () => {
                if (fallbackSrc) {
                    console.warn(`Failed to load ${src}, trying fallback: ${fallbackSrc}`);
                    img.src = fallbackSrc;
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load fallback image: ${fallbackSrc}`));
                } else {
                    reject(new Error(`Failed to load image: ${src}`));
                }
            };
        });
    }

    static async loadSound(audioContext, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            return await audioContext.decodeAudioData(arrayBuffer);
        } catch (error) {
            console.error(`Failed to load sound: ${url}`, error);
            throw new Error(`Failed to load sound: ${url}`);
        }
    }

    static async loadAssets() {
        try {
            const audioContext = new AudioContext(); 
            const [
                professoreidle,
                professorewalking,
		skullSprite,
                millyidle,
                millyspritesheet,
                millyinteract,
                suina1idle,
                suina1walking,
                suina1attack,
                suina2idle,
                suina2walking,
                suina2attack,
                suinaevilidle,
                suinaevilwalking,
                suinaevilattack,
                walteridle,
                walterwalking,
                walterattack,
                diegoidle,
                diegowalking,
                diegoattack,
                background1,
                background2,
                background3,
                background4,
                background5,
                proffuck,
                profpunch,
                profsmack,
		buzz,
                profstep,
                proftheme,
		skull,
                suinafuck,
                suinasound,
                suinaevil,
                suinawalk,
                waltersound,
                walterwelcome,
                diegosound,
                millysound
            ] = await Promise.all([
                this.loadImage('./assets/sprites/professore/professore-idle.png'),
                this.loadImage('./assets/sprites/professore/professore-spritesheet.png'),
 		this.loadImage('./assets/sprites/skull.png'),
                this.loadImage('./assets/sprites/milly/milly-idle.png'),
                this.loadImage('./assets/sprites/milly/milly-spritesheet.png'),
                this.loadImage('./assets/sprites/milly/milly-interact.png'),
                this.loadImage('./assets/sprites/suina1/suina1-idle.png'),
                this.loadImage('./assets/sprites/suina1/suina1-spritesheet.png'),
                this.loadImage('./assets/sprites/suina1/suina1-attack.png'),
                this.loadImage('./assets/sprites/suina2/suina2-idle.png'),
                this.loadImage('./assets/sprites/suina2/suina2-spritesheet.png'),
                this.loadImage('./assets/sprites/suina2/suina2-attack.png'),
                this.loadImage('./assets/sprites/suinaEvil/suinaevil-idle.png'),
                this.loadImage('./assets/sprites/suinaEvil/suinaevil-spritesheet.png'),
                this.loadImage('./assets/sprites/suinaEvil/suinaevil-attack.png'),
                this.loadImage('./assets/sprites/walter/walter-idle.png'),
                this.loadImage('./assets/sprites/walter/walter-spritesheet.png'),
                this.loadImage('./assets/sprites/walter/walter-attack.png'),
                this.loadImage('./assets/sprites/diego/diego-idle.png'),
                this.loadImage('./assets/sprites/diego/diego-spritesheet.png'),
                this.loadImage('./assets/sprites/diego/diego-attack.png'),
                this.loadImage('./assets/sprites/background.png'),
                this.loadImage('./assets/sprites/background2.png'),
                this.loadImage('./assets/sprites/background3.png'),
                this.loadImage('./assets/sprites/background4.png'),
                this.loadImage('./assets/sprites/background5.png'),
                this.loadSound(audioContext, './assets/sounds/prof-fuck.mp3'),
                this.loadSound(audioContext, './assets/sounds/prof-punch.mp3'),
                this.loadSound(audioContext, './assets/sounds/prof-smack.mp3'),
		this.loadSound(audioContext, './assets/sounds/buzz.mp3'), 
                this.loadSound(audioContext, './assets/sounds/prof-step.mp3'),
                this.loadSound(audioContext, './assets/sounds/prof-theme.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-fuck.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-sound.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-evil.mp3'),
                this.loadSound(audioContext, './assets/sounds/suina-walk.mp3'),
                this.loadSound(audioContext, './assets/sounds/walter-sound.mp3'),
                this.loadSound(audioContext, './assets/sounds/walter-welcome.mp3'),
                this.loadSound(audioContext, './assets/sounds/diego-sound.mp3'),
                this.loadSound(audioContext, './assets/sounds/milly-sound.mp3')
            ]);

            return {
                sprites: {
                    professore: { idle: professoreidle, walking: professorewalking, freeze: skullSprite },
                    milly: { idle: millyidle, spritesheet: millyspritesheet, interact: millyinteract },
                    suina1: { idle: suina1idle, walking: suina1walking, attack: suina1attack },
                    suina2: { idle: suina2idle, walking: suina2walking, attack: suina1attack },
                    suinaevil: { idle: suinaevilidle, walking: suinaevilwalking, attack: suina1attack },
                    walter: { idle: walteridle, walking: walterwalking, attack: walterattack },
                    diego: { idle: diegoidle, walking: diegowalking, attack: diegoattack }
                },
                backgrounds: {
                    background1,
                    background2,
                    background3,
                    background4,
                    background5
                },
                sounds: {
                    proffuck,
                    profpunch,
                    profsmack,
		    buzz,
                    profstep,
                    proftheme,
                    suinafuck,
                    suinasound,
                    suinaevil,
                    suinawalk,
                    waltersound,
                    walterwelcome,
                    diegosound,
                    millysound
                },
                audioContext
            };
        } catch (error) {
            console.error('Error loading assets:', error);
            throw new Error('Failed to load assets.');
        }
    }
}













CharacterRegistry.js:
// CharacterRegistry.js
export class CharacterRegistry {
    constructor() {
        this.characterClasses = new Map();
        this.characterStates = new Map();
    }

    registerCharacter(type, characterClass, stateDefinition) {
        this.characterClasses.set(type.toLowerCase(), {
            class: characterClass,
            defaultState: stateDefinition
        });
    }

    getCharacterClass(type) {
        return this.characterClasses.get(type.toLowerCase())?.class;
    }

    getDefaultState(type) {
        return this.characterClasses.get(type.toLowerCase())?.defaultState;
    }

    preserveState(character) {
        if (!character || !character.type) return null;

        const defaultState = this.getDefaultState(character.type);
        if (!defaultState) return null;

        // Create state object based on character's default state definition
        const state = {};
        for (const [key, definition] of Object.entries(defaultState)) {
            if (typeof definition === 'function') {
                state[key] = definition(character);
            } else {
                state[key] = character[key] ?? definition;
            }
        }

        return state;
    }
}















/* style.css */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  overflow: hidden;
  height: 100%;
  width: 100%;
}

canvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: block;
  background-color: #f0f0f0;
}

@media (max-width: 768px) {
  canvas {
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0;
    left: 0;
    transform: none;
  }
}


/* Back button styling */
#back-button {
  position: fixed;
  top: 20px;
  left: 20px;
  padding: 10px 20px;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 5px;
  font-size: 16px;
  cursor: pointer;
  z-index: 1000;
  transition: all 0.3s ease;
  display: none; /* Initially hidden */
}

#back-button:hover {
  background-color: rgba(0, 0, 0, 0.7);
}

@media (max-width: 768px) {
  #back-button {
    top: 10px;
    left: 10px;
    padding: 8px 16px;
    font-size: 14px;
  }
}


#controls-container {
  position: fixed;
  bottom: 20px;
  width: 100%;
  display: flex;
  justify-content: center;
  z-index: 10;
  pointer-events: none;
}

#controls {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  pointer-events: auto;
}

.action-buttons {
  position: absolute;
  width: 100%;
  display: flex;
  justify-content: space-between;
  padding: 0 5px; /* 5px padding from screen edges */
  bottom: 80px; /* Position above direction buttons */
}

.direction-buttons {
  display: flex;
  justify-content: center;
  gap: 5px;
  padding: 0 20px;
}

#controls button {
  width: 70px;
  height: 70px;
  font-size: 24px;
  border: none;
  border-radius: 50%;
  background-color: rgba(51, 51, 51, 0.8);
  color: white;
  transition: all 0.2s ease;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#controls .action-btn {
  width: 60px;
  height: 60px;
  font-weight: bold;
  background-color: rgba(76, 175, 80, 0.8);  /* Green tint for action buttons */
}

#controls button:active,
#controls button.active {
  transform: scale(0.9);
  background-color: rgba(76, 76, 76, 0.9);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

#controls .action-btn:active,
#controls .action-btn.active {
  background-color: rgba(56, 142, 60, 0.9);  /* Darker green when pressed */
}

@media (min-width: 769px) {
  #controls-container {
    display: none;
  }
}

/* Prevent text selection on mobile */
#controls button {
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

/* Ensure buttons don't cause scrolling on iOS */
#controls-container {
  touch-action: none;
}












LevelManager.js:
// LevelManager.js
import { CONFIG } from '../config.js';
import { CharacterRegistry } from '../utils/CharacterRegistry.js';
import { Suina1 } from '../characters/Suina1.js';
import { Suina2 } from '../characters/Suina2.js';
import { SuinaEvil } from '../characters/SuinaEvil.js';
import { Walter } from '../characters/Walter.js';
import { Diego } from '../characters/Diego.js';
import { Milly } from '../characters/Milly.js';

export class LevelManager {
    constructor(assets, gameState = null) {
        this.assets = assets;
        this.gameState = gameState;
        this.registry = new CharacterRegistry();
        this.currentLevel = 1;
        this.characters = [];
        this.characterTimers = {};
        this.player = null;
        this.transitionState = {
            inProgress: false,
            timeout: null,
            startTime: null,
            duration: 500,
            previousLevel: null,
            targetLevel: null
        };

        this.registerCharacters();
        this.setupBackButton();
    }

    // Helper method to check if game is in a stopped state
    isGameStopped() {
        return this.transitionState.inProgress || (this.gameState?.isGameOver ?? false);
    }

    registerCharacters() {
        this.registry.registerCharacter('suina1', Suina1);
        this.registry.registerCharacter('suina2', Suina2);
        this.registry.registerCharacter('suinaevil', SuinaEvil);
        this.registry.registerCharacter('walter', Walter);
        this.registry.registerCharacter('diego', Diego);
        this.registry.registerCharacter('milly', Milly);
    }

    setupBackButton() {
        const backButton = document.getElementById('back-button');
        if (!backButton) return;

        backButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (this.currentLevel !== 1) {
                this.transitionToLevel1();
            }
        });

        this.updateBackButtonVisibility();
    }

    updateBackButtonVisibility() {
        const backButton = document.getElementById('back-button');
        if (backButton) {
            backButton.style.display = this.currentLevel === 1 ? 'none' : 'block';
        }
    }

    async transitionToLevel1() {
        if (this.isGameStopped()) return;
        
        this.clearTimers();
        
        if (this.player) {
            this.player.x = CONFIG.WORLD.WIDTH / 2;
            this.player.y = CONFIG.WORLD.HEIGHT / 2;
        }

        await this.loadLevel(1, this.player);
        this.updateBackButtonVisibility();
    }

    async loadLevel(levelNumber, player) {
        const levelConfig = CONFIG.LEVELS[levelNumber];
        if (!levelConfig) {
            console.error(`Level ${levelNumber} configuration not found.`);
            return;
        }

        if (this.isGameStopped()) {
            console.warn('Level transition blocked - transition in progress or game over');
            return;
        }

        try {
            await this.startTransition(levelNumber);
            const storedStates = this.preserveCharacterStates();
            await this.clearCurrentLevel();
            await this.setupNewLevel(levelNumber, player, storedStates);
            await this.completeTransition();
            console.log(`Loaded level ${levelNumber}`);
        } catch (error) {
            console.error('Error during level transition:', error);
            this.handleTransitionError();
        }
    }

    async startTransition(newLevelNumber) {
        this.transitionState = {
            inProgress: true,
            startTime: performance.now(),
            previousLevel: this.currentLevel,
            targetLevel: newLevelNumber,
            duration: 500,
            timeout: null
        };

        if (this.transitionState.timeout) {
            clearTimeout(this.transitionState.timeout);
        }

        this.characters.forEach(char => {
            if (char && typeof char.pauseUpdates === 'function') {
                char.pauseUpdates();
            }
        });
    }

    preserveCharacterStates() {
        const storedStates = new Map();
        this.characters.forEach(char => {
            if (char && char.type) {
                const state = this.registry.preserveState(char);
                if (state) {
                    storedStates.set(char.type, state);
                }
            }
        });
        return storedStates;
    }

    async clearCurrentLevel() {
        this.clearTimers();
        


        this.characters.forEach(char => {
            if (char && typeof char.cleanup === 'function') {
                char.cleanup();
            }
        });

        this.characters = [];
        this.characterTimers = {};
    }

async setupNewLevel(levelNumber, player, storedStates) {
    this.currentLevel = levelNumber;
    
    if (this.player !== player) {
        this.player = player;
    }

    await this.loadCharactersForLevel(levelNumber, storedStates);
    this.updateBackButtonVisibility();
    this.resetPlayerState();

    // Make sure characters aren't paused after level setup
    this.characters.forEach(char => {
        if (char && char.resumeUpdates) {
            char.resumeUpdates();
        }
    });

    console.log('Level setup complete, characters:', this.characters.map(char => ({
        type: char.type,
        isPaused: char.isPaused,
        isIdle: char.isIdle
    })));
}


    resetPlayerState() {
        if (!this.player) return;

        const now = performance.now();
        this.player.lastUpdateTime = now;
        this.player.lastAnimationUpdate = now;
        this.player.frameTime = now;
        this.player.updateSpeedMultiplier();
        
        this.player.velocity = { x: 0, y: 0 };
        this.player.movementBuffer = { x: 0, y: 0 };

        if (!this.isGameStopped()) {
            this.player.x = CONFIG.WORLD.WIDTH / 2;
            this.player.y = CONFIG.WORLD.HEIGHT / 2;
        }

        this.player.frame = this.player.frame % this.player.totalFrames;
    }

async completeTransition() {
    return new Promise((resolve) => {
        const remainingTime = Math.max(0, 
            this.transitionState.duration - (performance.now() - this.transitionState.startTime));

        this.transitionState.timeout = setTimeout(() => {
            // Resume all characters
            this.characters.forEach(char => {
                if (char && char.resumeUpdates) {
                    console.log('Resuming character:', char.type);
                    char.resumeUpdates();
                }
            });

            this.transitionState = {
                inProgress: false,
                timeout: null,
                startTime: null,
                previousLevel: null,
                targetLevel: null,
                duration: 500
            };

            resolve();
        }, remainingTime);
    });
}

    handleTransitionError() {
        this.transitionState = {
            inProgress: false,
            timeout: null,
            startTime: null,
            previousLevel: null,
            targetLevel: null,
            duration: 500
        };

        if (!this.isGameStopped()) {
            this.characters.forEach(char => {
                if (char && typeof char.resumeUpdates === 'function') {
                    char.resumeUpdates();
                }
            });
        }
    }

        loadCharactersForLevel(levelNumber, storedStates) {
        switch (levelNumber) {
            case 1:
                this.addRandomCharacter('milly', 10000);
                break;
            case 2:
            case 3:
                // Start with Suina1 for initial spawn only
                if (this.characters.length === 0) {
                    this.addCharacter('suina1', 
                        Math.random() * (CONFIG.WORLD.WIDTH - CONFIG.PLAYER.WIDTH), 
                        Math.random() * (CONFIG.WORLD.HEIGHT - CONFIG.PLAYER.HEIGHT), 
                        storedStates);
                }
                break;
            case 4:
                this.addCharacter('walter', 600, 300);
                break;
            case 5:
                this.addCharacter('diego', 700, 400);
                break;
            default:
                console.warn(`No characters defined for level ${levelNumber}`);
                break;
        }
    }

    spawnNextRandomCharacter() {
        console.log("Spawning next random character...");
        // Only spawn in levels 2 or 3
        if (this.currentLevel !== 2 && this.currentLevel !== 3) {
            console.log("Not in level 2 or 3, skipping spawn");
            return;
        }

        // Include all three Suina types in random selection
        const characterTypes = ['suina1', 'suina2', 'suinaevil'];
        const characterType = characterTypes[Math.floor(Math.random() * characterTypes.length)];
        
        console.log(`Selected character type: ${characterType}`);
        
        // Random position
        const x = Math.random() * (CONFIG.WORLD.WIDTH - CONFIG.PLAYER.WIDTH);
        const y = Math.random() * (CONFIG.WORLD.HEIGHT - CONFIG.PLAYER.HEIGHT);
        
        this.addCharacter(characterType, x, y);
    }

    handleCharacterDisappear(character) {
        console.log(`Handling disappearance of character: ${character.type}`);
        
        // Remove the character from the array
        this.characters = this.characters.filter(c => c !== character);

        // If it's any Suina type in levels 2 or 3, spawn next random character
        if ((character.type === 'suina1' || character.type === 'suina2' || character.type === 'suinaevil') && 
            (this.currentLevel === 2 || this.currentLevel === 3)) {
            
            console.log("Triggering next random character spawn");
            this.spawnNextRandomCharacter();
        }
    }



addCharacter(type, x, y, storedStates = null) {
    console.log('Adding character:', { type, x, y });
    const CharacterClass = this.registry.getCharacterClass(type);
    const sprites = this.assets.sprites[type];

    if (!CharacterClass || !sprites) {
        console.error(`Invalid character type or missing sprites: ${type}`);
        return;
    }

    const character = new CharacterClass(x, y, CONFIG.PLAYER.WIDTH, CONFIG.PLAYER.HEIGHT, sprites, type.toLowerCase());

    if (storedStates) {
        const storedState = storedStates.get(type.toLowerCase());
        if (storedState) {
            Object.assign(character, storedState);
        }
    }

    character.isIdle = false;
    character.isPaused = false;  // Initialize as not paused
    character.levelManager = this;

    console.log('Character created:', {
        type: character.type,
        isPaused: character.isPaused,
        isIdle: character.isIdle
    });

    this.characters.push(character);
    return character;
}




    addDelayedCharacter(type, x, y, delay) {
        if (!this.assets.sprites[type]) {
            console.error(`Cannot add delayed character: Missing sprites for type ${type}`);
            return;
        }
        this.characterTimers[type] = setTimeout(() => {
            this.addCharacter(type, x, y);
            delete this.characterTimers[type];
        }, delay);
    }

    addRandomCharacter(type, interval) {
        const spawnRandomly = () => {
            if (this.currentLevel !== 1) return;
            const x = Math.random() * (CONFIG.WORLD.WIDTH - CONFIG.PLAYER.WIDTH);
            const y = Math.random() * (CONFIG.WORLD.HEIGHT - CONFIG.PLAYER.HEIGHT);
            this.addCharacter(type, x, y);
        };

        this.characterTimers[type] = setInterval(spawnRandomly, interval);
    }

update(player, worldBounds, input) {
        console.log('LevelManager Update:', {
            isGameStopped: this.isGameStopped(),
            characterCount: this.characters.length,
            characters: this.characters.map(char => ({
                type: char.type,
                position: { x: char.x, y: char.y },
                isPaused: char.isPaused,
                isCaught: char.isCaught
            }))
        });

        if (this.isGameStopped()) {
            console.log('LevelManager Update blocked by isGameStopped');
            return;
        }

        this.characters = this.characters.filter(character => character && character.type);

        console.log('Updating characters:', this.characters.length);

        this.characters.forEach((character) => {
            console.log('Updating character:', {
                type: character.type,
                isPaused: character.isPaused,
                isCaught: character.isCaught,
                isVisible: character.isVisible
            });

            if (!character.isCaught && !character.isPaused) {
                character.update(player, {
                    width: CONFIG.WORLD.WIDTH,
                    height: CONFIG.WORLD.HEIGHT
                }, input);
            } else {
                console.log('Character update skipped:', {
                    type: character.type,
                    isCaught: character.isCaught,
                    isPaused: character.isPaused
                });
            }
        });
    }

    checkLevelTransition(player) {
        if (this.isGameStopped()) return false;

        const currentLevelConfig = CONFIG.LEVELS[this.currentLevel];
        if (!currentLevelConfig || !currentLevelConfig.transitions) {
            return false;
        }

        for (const transition of Object.values(currentLevelConfig.transitions)) {
            if (
                player.x >= transition.x.min &&
                player.x <= transition.x.max &&
                player.y >= transition.y.min &&
                player.y <= transition.y.max
            ) {
                this.loadLevel(transition.nextLevel, player);
                return true;
            }
        }

        return false;
    }

    clearTimers() {
        for (const timer in this.characterTimers) {
            clearTimeout(this.characterTimers[timer]);
            clearInterval(this.characterTimers[timer]);
        }
        this.characterTimers = {};
    }



    getCurrentLevelBackground() {
        const levelConfig = CONFIG.LEVELS[this.currentLevel];
        if (!levelConfig) {
            console.error(`Level ${this.currentLevel} configuration not found.`);
            return null;
        }

        const backgroundKey = levelConfig.backgroundKey;
        return this.assets.backgrounds[backgroundKey];
    }
}

















AudioManager.js:
// AudioManager.js
// AudioManager.js
import { CONFIG } from '../../config.js';

export class AudioManager {
    constructor() {
        this.sounds = {};
        this.music = {};
        this.audioContext = null;
        this.musicGainNode = null;
        this.sfxGainNode = null;
        this.currentMusicSource = null;
        this.initialized = false;
        this.initializationPromise = null;
    }

    async init() {
        if (this.initializationPromise) {
            return this.initializationPromise;
        }

        this.initializationPromise = (async () => {
            try {
                console.log('Starting AudioManager initialization...');
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create and connect gain nodes
                this.musicGainNode = this.audioContext.createGain();
                this.sfxGainNode = this.audioContext.createGain();
                this.musicGainNode.connect(this.audioContext.destination);
                this.sfxGainNode.connect(this.audioContext.destination);

                // Set initial volumes
                this.musicGainNode.gain.setValueAtTime(CONFIG.AUDIO.MUSIC_VOLUME, this.audioContext.currentTime);
                this.sfxGainNode.gain.setValueAtTime(CONFIG.AUDIO.SFX_VOLUME, this.audioContext.currentTime);

                // Ensure audio context is resumed
                await this.ensureAudioContextResume();
                
                // Load all sounds
                await this.loadAllSounds();
                
                this.initialized = true;
                console.log('AudioManager initialized successfully');
                console.log('Available sounds:', Object.keys(this.sounds));

                // Start background music if available
                if (this.sounds['prof-theme']) {
                    await this.playBackgroundMusic();
                }

                return true;
            } catch (error) {
                console.error('AudioManager initialization failed:', error);
                this.initialized = false;
                throw error;
            }
        })();

        return this.initializationPromise;
    }

    async loadAllSounds() {
        console.log('Loading sounds...');
        try {
            const soundsToLoad = [
                ['buzz', './assets/sounds/buzz.mp3'],
                ['prof-theme', './assets/sounds/prof-theme.mp3'],
                ['professore_step', './assets/sounds/prof-step.mp3'],
                ['professore_fuck', './assets/sounds/prof-fuck.mp3'],
                ['professore_smack', './assets/sounds/prof-smack.mp3'],
                ['professore_punch', './assets/sounds/prof-punch.mp3'],
                ['walter_welcome', './assets/sounds/walter-welcome.mp3'],
                ['walter_sound', './assets/sounds/walter-sound.mp3'],
                ['suina_walk', './assets/sounds/suina-walk.mp3'],
                ['suina_sound', './assets/sounds/suina-sound.mp3'],
                ['suina_fuck', './assets/sounds/suina-fuck.mp3'],
                ['suina_evil', './assets/sounds/suina-evil.mp3'],
                ['milly_sound', './assets/sounds/milly-sound.mp3'],
                ['diego_sound', './assets/sounds/diego-sound.mp3']
            ];

            await Promise.all(
                soundsToLoad.map(([key, url]) => 
                    this.loadSound(key, url).catch(error => {
                        console.error(`Failed to load sound ${key}:`, error);
                        return null;
                    })
                )
            );

            console.log('All sounds loaded. Available sounds:', Object.keys(this.sounds));
        } catch (error) {
            console.error('Error loading sounds:', error);
            throw error;
        }
    }

    async loadSound(key, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            this.sounds[key] = audioBuffer;
            console.log(`Loaded sound: ${key}`);
        } catch (error) {
            console.error(`Failed to load sound ${key}:`, error);
            throw error;
        }
    }

    playBackgroundMusic() {
        if (!this.initialized || !this.sounds['prof-theme']) {
            console.warn('Cannot play background music - system not ready or music not loaded');
            return;
        }

        try {
            // Stop current music if playing
            if (this.currentMusicSource) {
                this.currentMusicSource.stop();
            }

            // Create new source
            this.currentMusicSource = this.audioContext.createBufferSource();
            this.currentMusicSource.buffer = this.sounds['prof-theme'];
            this.currentMusicSource.loop = true;
            this.currentMusicSource.connect(this.musicGainNode);
            this.currentMusicSource.start(0);
            console.log('Background music started');
        } catch (error) {
            console.error('Error playing background music:', error);
        }
    }

    async ensureAudioContextResume() {
        if (this.audioContext.state === 'suspended') {
            return new Promise((resolve) => {
                const resumeAudio = async () => {
                    await this.audioContext.resume();
                    window.removeEventListener('click', resumeAudio);
                    window.removeEventListener('keydown', resumeAudio);
                    resolve();
                };

                window.addEventListener('click', resumeAudio);
                window.addEventListener('keydown', resumeAudio);
            });
        }
        return Promise.resolve();
    }

    playSound(key, type = 'sfx') {
        if (!this.initialized) {
            console.warn('AudioManager not initialized. Cannot play sound:', key);
            return;
        }

        if (!this.sounds[key]) {
            console.warn(`Sound not found: ${key}. Available sounds:`, Object.keys(this.sounds));
            return;
        }

        try {
            const source = this.audioContext.createBufferSource();
            source.buffer = this.sounds[key];
            source.connect(type === 'music' ? this.musicGainNode : this.sfxGainNode);
            source.start(0);
            console.log(`Playing sound: ${key}`);
        } catch (error) {
            console.error(`Error playing sound ${key}:`, error);
        }
    }

    setMusicVolume(volume) {
        if (this.musicGainNode) {
            this.musicGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        }
    }

    setSFXVolume(volume) {
        if (this.sfxGainNode) {
            this.sfxGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        }
    }

    handleFootsteps(player, isMoving) {
        if (isMoving) {
            const now = Date.now();
            if (!this.lastFootstepTime || now - this.lastFootstepTime > CONFIG.AUDIO.FOOTSTEP_INTERVAL) {
                this.playSound('professore_step');
                this.lastFootstepTime = now;
            }
        }
    }
}

















Camera.js:
// Camera.js
import { CONFIG } from '../../config.js';

export class Camera {
    constructor(width, height) {
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.height = height;
    }

    follow(target, worldWidth, worldHeight) {
        const idealX = target.x + target.width / 2 - this.width / 2;
        const idealY = target.y + target.height / 2 - this.height / 2;

        this.x = this.clamp(idealX, 0, Math.max(0, worldWidth - this.width));
        this.y = this.clamp(idealY, 0, Math.max(0, worldHeight - this.height));

        if (worldWidth < this.width) {
            this.x = 0;
        }
        if (worldHeight < this.height) {
            this.y = 0;
        }
    }

    clamp(value, min, max) {
        return Math.max(min, Math.min(value, max));
    }
}












Input.js:
// Input.js
import { CONFIG } from '../../config.js';

export class InputHandler {
    constructor() {
        this.keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyF: false,
            KeyB: false
        };

        this.isMobile = window.innerWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT ||
            /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        this.touchState = {};
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Keyboard events
        window.addEventListener('keydown', (e) => this.setKey(e.code, true));
        window.addEventListener('keyup', (e) => this.setKey(e.code, false));

        if (this.isMobile) {
            this.setupTouchControls();
        }
    }

    setupTouchControls() {
        // Direction buttons
        const directions = ['up', 'down', 'left', 'right'];
        directions.forEach((dir) => {
            const element = document.getElementById(dir);
            if (element) {
                // Touch events
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, true);
                });
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, false);
                });
                element.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, false);
                });

                // Mouse events
                element.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, true);
                });
                element.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, false);
                });
                element.addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.handleDirectionTouch(e, dir, false);
                });
            }
        });

        // Action buttons
        const actionButtons = {
            'bacio': 'KeyB',
            'fuck': 'KeyF'
        };

        Object.entries(actionButtons).forEach(([buttonId, keyCode]) => {
            const element = document.getElementById(buttonId);
            if (element) {
                // Touch events
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, true);
                    element.classList.add('active');
                });
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, false);
                    element.classList.remove('active');
                });
                element.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, false);
                    element.classList.remove('active');
                });

                // Mouse events
                element.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, true);
                    element.classList.add('active');
                });
                element.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, false);
                    element.classList.remove('active');
                });
                element.addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.handleActionTouch(keyCode, false);
                    element.classList.remove('active');
                });
            }
        });
    }

    handleDirectionTouch(event, direction, isPressed) {
        const key = `Arrow${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
        this.setKey(key, isPressed);
        const element = document.getElementById(direction);
        if (element) {
            element.classList.toggle('active', isPressed);
        }
    }

    handleActionTouch(keyCode, isPressed) {
        this.setKey(keyCode, isPressed);
    }

    setKey(key, value) {
        if (this.keys.hasOwnProperty(key)) {
            this.keys[key] = value;
        }
    }

    isMoving() {
        return this.keys.ArrowUp || this.keys.ArrowDown || 
               this.keys.ArrowLeft || this.keys.ArrowRight;
    }
}













Renderer.js:
// Renderer.js
import { CONFIG } from '../../config.js';

export class Renderer {
    constructor(ctx, levelManager, gameState) {
        console.log('Initializing Renderer');
        this.ctx = ctx;
        this.levelManager = levelManager;
        this.gameState = gameState;
        this.directions = { down: 0, left: 1, right: 2, up: 3 };
        
        // Message system with both flashing and permanent messages
        this.screenMessages = {
            gameOver: {
                lines: ['Hai beccato', 'la Suina Mala... :('],
                startTime: 0,
                duration: 2000,
                interval: 400,
                isActive: false,
                nextMessage: 'finalGameOver'
            },
            finalGameOver: {
                lines: ['GAME OVER'],
                startTime: 0,
                duration: Infinity,  // Permanent message
                interval: 0,         // No flashing
                isActive: false,
                isPermanent: true    // Flag for permanent display
            },
            suinaMala: {
                lines: ['Suina mala!'],
                startTime: 0,
                duration: 800,
                interval: 200,
                isActive: false
            }
        };
        
        this.debug = true;
    }

    showSuinaMalaMessage() {
        console.log('Showing Suina Mala message');
        this.setScreenMessage('suinaMala', this.screenMessages.suinaMala.lines);
    }

    showGameOverMessage() {
        console.log('Showing Game Over message');
        this.setScreenMessage('gameOver', this.screenMessages.gameOver.lines);
    }

    setScreenMessage(type) {
        if (!this.screenMessages[type]) return;
        
        const message = this.screenMessages[type];
        message.startTime = performance.now();
        message.isActive = true;
    }

    drawScreenMessage(type) {
        const message = this.screenMessages[type];
        if (!message || !message.isActive) return;

        const currentTime = performance.now();
        const elapsed = currentTime - message.startTime;
        
        // Handle message duration
        if (elapsed > message.duration && !message.isPermanent) {
            message.isActive = false;
            
            // If there's a next message, show it
            if (message.nextMessage) {
                this.setScreenMessage(message.nextMessage);
            }
            return;
        }

        // Determine visibility based on whether message is permanent or flashing
        const isVisible = message.isPermanent || (Math.floor((elapsed / message.interval)) % 2 === 0);
        
        if (isVisible) {
            this.ctx.save();
            this.ctx.font = 'bold 32px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 3;
            
            const x = this.ctx.canvas.width / 2;
            const baseY = this.ctx.canvas.height / 2;
            
            message.lines.forEach((line, index) => {
                const y = baseY + (index - (message.lines.length - 1) / 2) * 40;
                this.ctx.strokeText(line, x, y);
                this.ctx.fillText(line, x, y);
            });
            
            this.ctx.restore();
        }
    }



    clear() {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }




    setScreenMessage(type, message, duration = null) {
        console.log(`Setting screen message: ${type}`, message);
        
        if (!this.screenMessages[type]) return;
        
        const messageConfig = this.screenMessages[type];
        messageConfig.startTime = performance.now();
        messageConfig.isActive = true;
        
        if (duration) {
            messageConfig.duration = duration;
        }

        if (Array.isArray(message)) {
            messageConfig.lines = message;
        } else {
            messageConfig.lines = [message];
        }
    }

    drawScreenMessage(type) {
        const message = this.screenMessages[type];
        if (!message || !message.isActive) return;

        const currentTime = performance.now();
        const elapsed = currentTime - message.startTime;
        
        console.log(`Drawing ${type} message, elapsed time:`, elapsed);

        if (elapsed > message.duration) {
            console.log(`${type} message duration expired`);
            message.isActive = false;
            return;
        }

        const flashPhase = Math.floor((elapsed / message.interval));
        const isVisible = flashPhase % 2 === 0;
        
        console.log(`${type} message state:`, { flashPhase, isVisible });

        if (isVisible) {
            this.ctx.save();
            this.ctx.font = 'bold 32px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 3;
            
            const x = this.ctx.canvas.width / 2;
            const baseY = this.ctx.canvas.height / 2;
            
            message.lines.forEach((line, index) => {
                const y = baseY + (index - (message.lines.length - 1) / 2) * 40;
                this.ctx.strokeText(line, x, y);
                this.ctx.fillText(line, x, y);
            });
            
            this.ctx.restore();
        }
    }

    setFlashMessage(message, duration) {
        this.setScreenMessage('flash', message, duration);
    }

    drawBackground(background, camera) {
        if (background) {
            this.ctx.drawImage(
                background,
                camera.x, camera.y,
                camera.width, camera.height,
                0, 0,
                camera.width, camera.height
            );
        }
    }

    draw(player, sprites, camera) {
        console.log('Starting render cycle');

        // Draw background
        this.clear();
        this.drawBackground(this.levelManager.getCurrentLevelBackground(), camera);
        
        // Draw characters
        console.log('Drawing characters');
        if (this.levelManager?.characters) {
            this.drawCharacters(camera);
        }
        
        // Draw player
        if (player && sprites.professore) {
            this.drawPlayer(player, sprites.professore, camera);
        }
        
        // Draw any active screen messages
        Object.keys(this.screenMessages).forEach(type => {
            if (this.screenMessages[type].isActive) {
                this.drawScreenMessage(type);
            }
        });

        console.log('Render cycle complete');
    }

    drawPlayer(player, sprites, camera) {
        if (!player) return;

        const drawX = player.x - camera.x;
        const drawY = player.y - camera.y;

        // Game Over State Handling
        if (this.gameState?.isGameOver && 
            this.gameState.gameOverType === 'jail' && 
            player.freeze) {
            
            console.log('Drawing frozen player state');
            
            // Draw freeze sprite (skull)
            if (sprites.freeze) {
                this.ctx.drawImage(sprites.freeze, drawX, drawY, player.width, player.height);
                
                // Draw jail overlay
                const jailOverlay = this.gameState.getJailOverlay();
                if (jailOverlay) {
                    const overlayWidth = player.width * 1.5;
                    const overlayHeight = player.height * 1.5;
                    const overlayX = drawX - (overlayWidth - player.width) / 2;
                    const overlayY = drawY - (overlayHeight - player.height) / 2;
                    
                    this.ctx.drawImage(
                        jailOverlay, 
                        overlayX, overlayY, 
                        overlayWidth, overlayHeight
                    );
                }
            }
            return;
        }

        // Normal State Rendering
        if (player.isIdle) {
            if (sprites.idle) {
                this.ctx.drawImage(sprites.idle, drawX, drawY, player.width, player.height);
            }
        } else {
            const directionIndex = this.directions[player.direction] || this.directions['down'];
            const spriteX = player.frame * player.width;
            const spriteY = directionIndex * player.height;

            if (sprites.walking) {
                this.ctx.drawImage(
                    sprites.walking,
                    spriteX, spriteY,
                    player.width, player.height,
                    drawX, drawY,
                    player.width, player.height
                );
            }
        }
    }

    drawCharacters(camera) {
        if (!this.levelManager?.characters) return;
        
        this.levelManager.characters.forEach(character => {
            if (!character || !character.type || !character.isVisible) return;

            const drawX = character.x - camera.x;
            const drawY = character.y - camera.y;

            if (character.currentSprite === 'attack' && character.activeSprite) {
                this.ctx.drawImage(character.activeSprite, drawX, drawY, 
                    character.width, character.height);
                return;
            }

            if (character.isIdle && character.sprites?.idle) {
                this.ctx.drawImage(character.sprites.idle, drawX, drawY, 
                    character.width, character.height);
            } else if (character.sprites?.walking) {
                const directionIndex = this.directions[character.direction] || this.directions['down'];
                const spriteX = character.frame * character.width;
                const spriteY = directionIndex * character.height;

                this.ctx.drawImage(
                    character.sprites.walking,
                    spriteX, spriteY,
                    character.width, character.height,
                    drawX, drawY,
                    character.width, character.height
                );
            }
        });
    }

    setFlashStartTime() {
        const startTime = performance.now();
        this.screenMessages.gameOver.startTime = startTime;
        if (this.debug) {
            console.log('Flash start time set to:', startTime);
        }
    }
}












ScoreManager.js:
// ScoreManager.js
import { ScoreAnimation } from './ScoreAnimation.js';

export class ScoreManager {
    constructor(ctx) {
        this.ctx = ctx;
        this.scores = {
            energy: 0,
            love: 0,
            friendship: 0
        };
        this.maxScore = 100;
        this.barWidth = 150;
        this.barHeight = 10;
        this.padding = 10;
        this.colors = {
            energy: '#ff4444',    // Red for Energy
            love: '#ff69b4',      // Pink for Love
            friendship: '#4CAF50'  // Green for Friendship
        };
        this.barSpacing = 5;
        this.textPadding = 5;
        
        // Initialize score animation system
        this.scoreAnimation = new ScoreAnimation();
    }

    increaseScore(type, amount) {
        if (this.scores.hasOwnProperty(type)) {
            const oldScore = this.scores[type];
            this.scores[type] = Math.min(this.maxScore, oldScore + amount);
            
            // If it's a love score increase, trigger animation
            if (type === 'love' && amount > 0) {
                this.scoreAnimation.addAnimation(amount);
            }
        }
    }

    draw() {
        this.ctx.save();

        // Draw score bars
        Object.entries(this.scores).forEach(([type, score], index) => {
            const x = this.ctx.canvas.width - this.barWidth - this.padding;
            const y = this.padding + (index * (this.barHeight + this.barSpacing));

            // Draw label with shadow for better visibility
            this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            this.ctx.shadowBlur = 2;
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = 'bold 10px Arial';
            this.ctx.textAlign = 'right';
            this.ctx.fillText(type.toUpperCase(), x - this.textPadding, y + this.barHeight);
            
            // Reset shadow for bars
            this.ctx.shadowBlur = 0;

            // Draw background bar with slight transparency
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            this.ctx.fillRect(x, y, this.barWidth, this.barHeight);

            // Draw score bar
            this.ctx.fillStyle = this.colors[type];
            const fillWidth = (score / this.maxScore) * this.barWidth;
            this.ctx.fillRect(x, y, fillWidth, this.barHeight);
        });

        // Draw any active score animations
        this.scoreAnimation.update(this.ctx);

        this.ctx.restore();
    }
}













ScoreAnimation.js:
// ScoreAnimation.js
export class ScoreAnimation {
    constructor() {
        this.animations = [];
        this.scoreCountdownElement = null;
        this.isResetting = false;
        this.countdownAnimationFrame = null;
    }

    addAnimation(score, isNegative = false) {
        const canvas = document.getElementById('gameCanvas');
        const centerX = Math.round(canvas.width / 2);
        const centerY = Math.round(canvas.height / 2);
        
        this.animations.push({
            score: `${isNegative ? '-' : '+'}${score}`,
            x: centerX,
            y: centerY,
            startTime: performance.now(),
            duration: 2000,
            startFontSize: 72,
            endFontSize: 24,
            opacity: 1
        });
    }

    update(ctx) {
        const currentTime = performance.now();
        
        for (let i = this.animations.length - 1; i >= 0; i--) {
            const anim = this.animations[i];
            const elapsed = currentTime - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);

            // Smooth easing function
            const easeOutCubic = 1 - Math.pow(1 - progress, 3);

            // Calculate current font size
            const fontSize = Math.round(anim.startFontSize + (anim.endFontSize - anim.startFontSize) * easeOutCubic);
            
            // Calculate opacity (fade out in the last 30% of animation)
            anim.opacity = progress > 0.7 ? 1 - ((progress - 0.7) / 0.3) : 1;

            ctx.save();
            
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Move upward as it fades
            const yOffset = 50 * easeOutCubic;

            // Draw text outline
            ctx.strokeStyle = `rgba(0, 0, 0, ${anim.opacity * 0.5})`;
            ctx.lineWidth = 3;
            ctx.strokeText(anim.score, anim.x, anim.y - yOffset);

            // Draw text fill
            ctx.fillStyle = `rgba(255, 192, 203, ${anim.opacity})`;
            ctx.fillText(anim.score, anim.x, anim.y - yOffset);

            ctx.restore();

            if (progress >= 1) {
                this.animations.splice(i, 1);
            }
        }
    }


    animateScoreReset(scoreManager, onComplete) {
        if (this.isResetting) return;
        
        this.isResetting = true;
        const scores = scoreManager.scores;
        const startScores = { ...scores };
        const animationDuration = 2000;
        const startTime = performance.now();
        const startFontSize = 120; // Starting larger
        const endFontSize = 48;   // Ending smaller

        this.createCountdownElement(startFontSize);

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);

            // Easing function for smooth animation
            const easeInOutQuad = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            // Animate scores down
            Object.keys(scores).forEach(type => {
                scores[type] = Math.round(startScores[type] * (1 - easeInOutQuad));
            });

            // Update countdown number with size and opacity animation
            const countdownValue = Math.round(100 * (1 - easeInOutQuad));
            if (this.scoreCountdownElement) {
                // Calculate current font size
                const currentFontSize = startFontSize - (startFontSize - endFontSize) * easeInOutQuad;
                
                // Calculate opacity (start fading halfway through)
                const opacity = progress > 0.5 ? 2 * (1 - progress) : 1;
                
                this.scoreCountdownElement.style.fontSize = `${currentFontSize}px`;
                this.scoreCountdownElement.style.opacity = opacity;
                this.scoreCountdownElement.textContent = countdownValue;
            }

            if (progress < 1) {
                this.countdownAnimationFrame = requestAnimationFrame(animate);
            } else {
                this.cleanup();
                this.isResetting = false;
                if (onComplete) onComplete();
            }
        };

        this.countdownAnimationFrame = requestAnimationFrame(animate);
    }

    createCountdownElement(fontSize) {
        this.scoreCountdownElement = document.createElement('div');
        this.scoreCountdownElement.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: ${fontSize}px;
            font-family: 'Arial Black', Arial;
            color: white;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5),
                         -3px -3px 6px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transition: transform 0.1s ease-out;
            opacity: 1;
        `;
        document.body.appendChild(this.scoreCountdownElement);
    }


    cleanup() {
        if (this.countdownAnimationFrame) {
            cancelAnimationFrame(this.countdownAnimationFrame);
            this.countdownAnimationFrame = null;
        }
        
        if (this.scoreCountdownElement) {
            document.body.removeChild(this.scoreCountdownElement);
            this.scoreCountdownElement = null;
        }
    }
}










GameStateManager.js:
// GameStateManager.js
export class GameStateManager {
    constructor(game) {
        this.game = game;
        this.isGameOver = false;
        this.gameOverType = null;
        this.jailOverlay = null;
        this.transitionState = {
            active: false,
            startTime: null,
            duration: 1000
        };
        this.initializeJailOverlay();  // Changed name to be more accurate
    }

    initializeJailOverlay() {  // Renamed method
        try {
            this.jailOverlay = new Image();
            this.jailOverlay.src = './assets/sprites/jail.png';
            
            this.jailOverlay.onload = () => {
                console.log('Jail overlay loaded successfully');
            };
            
            this.jailOverlay.onerror = (error) => {
                console.error('Failed to load jail overlay:', error);
            };
        } catch (error) {
            console.error('Error initializing jail overlay:', error);
        }
    }

    triggerJailGameOver(player) {
        console.log('Triggering jail game over sequence');
        if (this.isGameOver) return;

        this.isGameOver = true;
        this.gameOverType = 'jail';
        this.transitionState.active = true;
        this.transitionState.startTime = performance.now();

        // Use the centralized message system
        if (this.game.renderer) {
            this.game.renderer.showGameOverMessage();
        }

        // Set flash start time in renderer
        if (this.game.renderer) {
            console.log('Setting flash start time');
            this.game.renderer.setFlashStartTime();
        } else {
            console.warn('Renderer not available for flash timing');
        }

        // Handle player state
        if (player) {
            console.log('Setting player game over state');
            player.freeze = true;
            player.isIdle = true;
            player.velocity = { x: 0, y: 0 };
            player.movementBuffer = { x: 0, y: 0 };
        }

        // Stop background music with fade out
        if (this.game.audioManager?.currentMusicSource) {
            const gainNode = this.game.audioManager.musicGainNode;
            const currentTime = this.game.audioManager.audioContext.currentTime;
            gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
            gainNode.gain.linearRampToValueAtTime(0, currentTime + 1);
            
            setTimeout(() => {
                this.game.audioManager.currentMusicSource.stop();
            }, 1000);
        }

        // Animate score reset
        if (this.game.scoreManager) {
            this.game.scoreManager.scoreAnimation.animateScoreReset(
                this.game.scoreManager,
                () => {
                    console.log('Score reset animation complete');
                    this.transitionState.active = false;
                }
            );
        }
    }

    isInTransition() {
        if (!this.transitionState.active) return false;
        const elapsed = performance.now() - this.transitionState.startTime;
        return elapsed < this.transitionState.duration;
    }

    getJailOverlay() {
        return this.jailOverlay?.complete ? this.jailOverlay : null;
    }

    reset() {
        this.isGameOver = false;
        this.gameOverType = null;
        this.transitionState.active = false;
        this.transitionState.startTime = null;

        // Reset player state if available
        if (this.game?.player) {
            this.game.player.freeze = false;
            if (this.game.assets?.sprites?.professore) {
                this.game.player.sprites = this.game.assets.sprites.professore;
            }
        }

        // Reset score animation if available
        if (this.game?.scoreManager?.scoreAnimation) {
            this.game.scoreManager.scoreAnimation.cleanup();
        }

        // Reset audio if available
        if (this.game?.audioManager) {
            this.game.audioManager.musicGainNode.gain.setValueAtTime(
                this.game.audioManager.musicGainNode.gain.defaultValue,
                this.game.audioManager.audioContext.currentTime
            );
        }
    }
}












BaseCharacter.js:
// BaseCharacter.js
import { CONFIG } from '../config.js';

export class BaseCharacter {
    constructor(x, y, width, height, sprites, type, speedMultiplier = 1) {
        console.log('BaseCharacter Constructor:', {
            x, y, width, height, type, speedMultiplier
        });

        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.sprites = sprites;
        this.type = type.toLowerCase();

        // Movement and animation
        this.speed = CONFIG.PLAYER.SPEED * speedMultiplier;
        this.direction = 'down';
        this.isIdle = true;
        this.frame = 0;
        this.totalFrames = CONFIG.PLAYER.TOTAL_FRAMES;
        this.animationSpeed = 100;
        this.lastAnimationUpdate = performance.now();
        this.isCaught = false;
        this.isPaused = false;

        console.log('BaseCharacter Initialized:', {
            speed: this.speed,
            direction: this.direction,
            isIdle: this.isIdle,
            totalFrames: this.totalFrames,
            isPaused: this.isPaused
        });
    }

update(player, worldBounds, input) {
        console.log('BaseCharacter Update ENTRY:', {
            type: this.type,
            isPaused: this.isPaused,
            isCaught: this.isCaught,
            isVisible: this.isVisible,
            position: { x: this.x, y: this.y }
        });

        if (this.isPaused || this.isCaught) {
            console.log('BaseCharacter Update BLOCKED by:', {
                isPaused: this.isPaused,
                isCaught: this.isCaught
            });
            return;
        }

        const currentTime = performance.now();
        const deltaTime = Math.min((currentTime - (this.lastUpdateTime || currentTime)) / 16.67, 32);
        this.lastUpdateTime = currentTime;

        console.log('BaseCharacter calling updateBehavior with:', {
            deltaTime,
            currentTime,
            lastUpdateTime: this.lastUpdateTime
        });

        this.updateBehavior(player, worldBounds, deltaTime, input);

        console.log('BaseCharacter after updateBehavior:', {
            isIdle: this.isIdle,
            frame: this.frame,
            position: { x: this.x, y: this.y }
        });

        if (!this.isIdle) {
            if (currentTime - this.lastAnimationUpdate >= this.animationSpeed) {
                this.frame = (this.frame + 1) % this.totalFrames;
                this.lastAnimationUpdate = currentTime;
                console.log('BaseCharacter animation updated:', {
                    frame: this.frame,
                    animationTime: currentTime - this.lastAnimationUpdate
                });
            }
        }
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        console.log('BaseCharacter updateBehavior called');
        this.isIdle = true;
    }

    checkCollision(other) {
        const collision = (
            this.x < other.x + other.width &&
            this.x + this.width > other.x &&
            this.y < other.y + other.height &&
            this.y + this.height > other.y
        );
        
        if (collision) {
            console.log('Collision detected:', {
                myPos: { x: this.x, y: this.y },
                otherPos: { x: other.x, y: other.y }
            });
        }
        
        return collision;
    }

    pauseUpdates() {
        console.log('Character paused');
        this.isPaused = true;
    }

    resumeUpdates() {
        console.log('Character resumed');
        this.isPaused = false;
        this.lastUpdateTime = performance.now();
        this.lastAnimationUpdate = performance.now();
    }

    cleanup() {
        console.log('Character cleanup');
        this.isPaused = false;
    }
}











Player.js:
// Player.js
import { CONFIG } from '../config.js';
import { BaseCharacter } from './BaseCharacter.js';

export class Player extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
        this.lastUpdateTime = performance.now();
        this.frameTime = performance.now();
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.currentInput = null;
        this.updateSpeedMultiplier();
        this.spriteState = {
            current: 'idle',
            frame: 0,
            lastUpdate: performance.now()
        };
    }

    forceStateUpdate() {
        const now = performance.now();
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.lastAnimationUpdate = now;
        this.spriteState.lastUpdate = now;
        
        // Update sprite state based on current movement
        this.updateSpriteState(!this.isIdle);
    }

    updateSpriteState(isMoving) {
        const now = performance.now();
        const spriteType = isMoving ? 'walking' : 'idle';
        
        // Only update if state actually changed
        if (this.spriteState.current !== spriteType) {
            this.spriteState.current = spriteType;
            this.spriteState.frame = 0;
            this.spriteState.lastUpdate = now;
            this.frame = 0; // Reset animation frame
        }
    }

    determineSpeedMultiplier() {
        const screenWidth = window.innerWidth;
        if (screenWidth <= CONFIG.CANVAS.MOBILE_BREAKPOINT) {
            return CONFIG.PLAYER.SPEED_MULTIPLIERS.MOBILE;
        } else if (screenWidth <= 1024) {
            return CONFIG.PLAYER.SPEED_MULTIPLIERS.TABLET;
        }
        return CONFIG.PLAYER.SPEED_MULTIPLIERS.DESKTOP;
    }

    updateSpeedMultiplier() {
        this.speedMultiplier = this.determineSpeedMultiplier();
        this.speed = CONFIG.PLAYER.SPEED * this.speedMultiplier;
    }

    update(input, worldBounds) {
        const currentTime = performance.now();
        
        // Limit deltaTime to prevent extreme values
        const maxDeltaTime = 32;
        const rawDeltaTime = (currentTime - this.lastUpdateTime) / 16.67;
        const deltaTime = Math.min(rawDeltaTime, maxDeltaTime);
        
        this.lastUpdateTime = currentTime;
        this.frameTime += deltaTime * 16.67;

        // Store previous state
        const wasMoving = !this.isIdle;
        
        // Update movement and state
        this.updateBehavior(input, worldBounds, deltaTime);
        
        // Check if movement state changed
        const isMoving = !this.isIdle;
        if (wasMoving !== isMoving) {
            this.updateSpriteState(isMoving);
        }

        // Update animation
        if (isMoving) {
            if (currentTime - this.spriteState.lastUpdate >= this.animationSpeed) {
                this.frame = (this.frame + 1) % this.totalFrames;
                this.spriteState.lastUpdate = currentTime;
            }
        }
    }



updateBehavior(input, worldBounds, deltaTime) {
    // If player is frozen, don't process any movement
    if (this.freeze) {
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        this.isIdle = true;
        return;
    }

    // Store current input for state preservation
    this.currentInput = { ...input.keys };
    
    const moving = input.isMoving();
    this.isIdle = !moving;

    if (moving) {
        const adjustedSpeed = this.speed * deltaTime;
        const keys = input.keys;
        
        // Reset velocity
        this.velocity.x = 0;
        this.velocity.y = 0;

        // Calculate velocity based on input
        if (keys.ArrowRight) {
            this.velocity.x = adjustedSpeed;
            this.direction = 'right';
        }
        if (keys.ArrowLeft) {
            this.velocity.x = -adjustedSpeed;
            this.direction = 'left';
        }
        if (keys.ArrowDown) {
            this.velocity.y = adjustedSpeed;
            this.direction = 'down';
        }
        if (keys.ArrowUp) {
            this.velocity.y = -adjustedSpeed;
            this.direction = 'up';
        }

        // Add to movement buffer
        this.movementBuffer.x += this.velocity.x;
        this.movementBuffer.y += this.velocity.y;

        // Apply whole pixel movements
        const newX = this.x + Math.round(this.movementBuffer.x);
        const newY = this.y + Math.round(this.movementBuffer.y);

        // Clamp to world bounds
        this.x = Math.min(Math.max(newX, 0), worldBounds.width - this.width);
        this.y = Math.min(Math.max(newY, 0), worldBounds.height - this.height);

        // Remove used movement from buffer
        this.movementBuffer.x -= Math.round(this.movementBuffer.x);
        this.movementBuffer.y -= Math.round(this.movementBuffer.y);

        // Update last position
        this.lastX = this.x;
        this.lastY = this.y;
    } else {
        // Reset movement buffer when idle
        this.movementBuffer.x = 0;
        this.movementBuffer.y = 0;
    }
 }
}









Suina1.js:
// Suina1.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class Suina1 extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 1.5);
        
        const now = performance.now();
        
        this.moveTimer = now;
        this.changeDirectionInterval = 2500;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = now;

        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.disappearanceTimer = null;
        this.canInteract = false;

        this.isPaused = false;

        if (this.sprites && this.sprites.walking) {
            this.currentSprite = 'walking';
            this.activeSprite = this.sprites.walking;
        }
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible) {
            return;
        }

        const isCollidingNow = this.checkCollision(player);

        // First collision detection
        if (isCollidingNow && !this.isColliding && !this.isDisappearing && !this.disappearanceTimer) {
            // Change sprite and play sound
            if (this.sprites.attack) {
                this.currentSprite = 'attack';
                this.activeSprite = this.sprites.attack;
                this.frame = 0;
            }

            const gameInstance = window.gameInstance;
            if (!this.soundPlayed && gameInstance?.audioManager) {
                gameInstance.audioManager.playSound('suina_sound');
                this.soundPlayed = true;
            }

            this.canInteract = true;

            // Set disappearance timer for 2 seconds
            this.disappearanceTimer = setTimeout(() => {
                this.startDisappearance();
            }, 2000);

            this.isColliding = true;
            this.velocity = { x: 0, y: 0 };
            this.movementBuffer = { x: 0, y: 0 };
            this.isIdle = true;
        }

        // Handle button interactions within the 2-second window
        if (this.canInteract && !this.isDisappearing) {
            const gameInstance = window.gameInstance;
            
            if (input.keys.KeyB) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('professore_smack');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 2);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
            else if (input.keys.KeyF) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('suina_fuck');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 5);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
        }

        // Handle movement if not in collision or disappearing state
        if (!this.isColliding && !this.isDisappearing) {
            const distance = Math.hypot(player.x - this.x, player.y - this.y);
            if (distance < 150) {
                this.runAwayFrom(player, deltaTime, worldBounds);
                this.isIdle = false;
            } else {
                this.moveRandomly(deltaTime, worldBounds);
            }
        }
    }

startDisappearance() {
        console.log('Starting disappearance sequence for Suina1');
        this.isDisappearing = true;
        this.isVisible = false;
        this.canInteract = false;
        
        // Clear any existing timer
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        // Notify level manager about disappearance
        if (this.levelManager) {
            console.log('Notifying LevelManager about Suina1 disappearance');
            this.levelManager.handleCharacterDisappear(this);
        } else {
            console.warn('No levelManager reference found in Suina1');
        }
    }

    respawn() {
        const padding = 100;
        
        // Calculate valid spawn area
        const minX = padding;
        const maxX = CONFIG.WORLD.WIDTH - this.width - padding;
        const minY = padding;
        const maxY = CONFIG.WORLD.HEIGHT - this.height - padding;
        
        // Generate random position within valid bounds
        this.x = Math.floor(minX + Math.random() * (maxX - minX));
        this.y = Math.floor(minY + Math.random() * (maxY - minY));
        
        // Reset all states
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.currentSprite = 'walking';
        this.activeSprite = this.sprites.walking;
        this.canInteract = false;
        
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        // Reset movement parameters
        const now = performance.now();
        this.moveTimer = now;
        this.lastDirectionChange = now;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.isIdle = false;
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        
        // Set random initial direction
        const directions = ['up', 'down', 'left', 'right'];
        this.direction = directions[Math.floor(Math.random() * directions.length)];
        this.lastNonIdleDirection = this.direction;
    }

    cleanup() {
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }
        this.canInteract = false;
        super.cleanup();
    }

  


    resetCollisionState() {
        if (!this.isDisappearing) {
            this.isColliding = false;
            this.soundPlayed = false;
            this.currentSprite = 'walking';
            this.activeSprite = this.sprites.walking;
        }
    }

    handleMovement(player, worldBounds, deltaTime) {
        // Your existing movement code here...
        const currentTime = performance.now();
        const maxDeltaTime = 32;
        const effectiveDeltaTime = Math.min(deltaTime, maxDeltaTime);
        const distance = Math.hypot(player.x - this.x, player.y - this.y);

        if (distance < 150) {
            this.runAwayFrom(player, effectiveDeltaTime, worldBounds);
        } else {
            this.moveRandomly(effectiveDeltaTime, worldBounds);
        }
    }



    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        const adjustedSpeed = this.speed * deltaTime * 1.2;

        const oldX = this.x;
        const oldY = this.y;

        const randomOffset = Math.random() * 0.2 - 0.1;
        const finalAngle = angle + randomOffset;

        this.x = Math.min(Math.max(this.x + Math.cos(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.width - this.width);
        this.y = Math.min(Math.max(this.y + Math.sin(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.height - this.height);

        if (this.x !== oldX || this.y !== oldY) {
            this.updateDirection(this.x - oldX, this.y - oldY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }
    }

    handleCollision(player, input) {
        const gameInstance = window.gameInstance;

        // Initial collision detection
        if (!this.isColliding && !this.isDisappearing && this.isVisible) {
            // Stop all movement and set initial states
            this.isColliding = true;
            this.velocity = { x: 0, y: 0 };
            this.movementBuffer = { x: 0, y: 0 };
            this.isIdle = true;
            this.buttonInteractionAvailable = true;

            // Play sound once
            if (!this.soundPlayed && gameInstance.audioManager) {
                gameInstance.audioManager.playSound('suina_sound');
                this.soundPlayed = true;
            }

            // Change to attack sprite
            if (this.sprites.attack) {
                this.currentSprite = 'attack';
                this.activeSprite = this.sprites.attack;
                this.frame = 0;
            }
        }

        // Handle button interactions
        if (this.buttonInteractionAvailable) {
            if (input.keys.KeyB || input.keys.KeyF) {
                if (input.keys.KeyB && gameInstance.audioManager) {
                    gameInstance.audioManager.playSound('professore_smack');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 2);
                    }
                } else if (input.keys.KeyF && gameInstance.audioManager) {
                    gameInstance.audioManager.playSound('suina_fuck');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 5);
                    }
                }

                if (this.sprites.attack) {
                    this.currentSprite = 'attack';
                    this.activeSprite = this.sprites.attack;
                    this.frame = 0;
                }

                this.hasInteracted = true;
                this.buttonInteractionAvailable = false;
                this.startDisappearance();
            }
        }
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const oldX = this.x;
        const oldY = this.y;

        switch (this.direction) {
            case 'up':
                this.y = Math.max(this.y - adjustedSpeed, 0);
                break;
            case 'down':
                this.y = Math.min(this.y + adjustedSpeed, worldBounds.height - this.height);
                break;
            case 'left':
                this.x = Math.max(this.x - adjustedSpeed, 0);
                break;
            case 'right':
                this.x = Math.min(this.x + adjustedSpeed, worldBounds.width - this.width);
                break;
        }

        const moved = (Math.abs(this.x - oldX) > 0.01 || Math.abs(this.y - oldY) > 0.01);

        if (moved) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
            this.stuckTimer = 0;
        } else {
            this.stuckTimer += deltaTime * 16.67;
        }

        return moved;
    }

    randomizeDirection(worldBounds) {
        const { width, height } = worldBounds;
        const edgeBuffer = 50;
        const cornerBuffer = 100;
        
        const nearLeft = this.x < edgeBuffer;
        const nearRight = this.x > width - this.width - edgeBuffer;
        const nearTop = this.y < edgeBuffer;
        const nearBottom = this.y > height - this.height - edgeBuffer;

        let directions = ['up', 'down', 'left', 'right'];

        if (this.directionChangeCount < 3) {
            if (!nearLeft && !nearRight && !nearTop && !nearBottom) {
                if (Math.random() < 0.7) {
                    return;
                }
            }
        }

        // Filter out directions based on position
        if (nearLeft) directions = directions.filter(d => d !== 'left');
        if (nearRight) directions = directions.filter(d => d !== 'right');
        if (nearTop) directions = directions.filter(d => d !== 'up');
        if (nearBottom) directions = directions.filter(d => d !== 'down');

        // Special handling for corners
        if (this.x < cornerBuffer && this.y < cornerBuffer) {
            directions = ['right', 'down'];
        } else if (this.x > width - cornerBuffer && this.y < cornerBuffer) {
            directions = ['left', 'down'];
        } else if (this.x < cornerBuffer && this.y > height - cornerBuffer) {
            directions = ['right', 'up'];
        } else if (this.x > width - cornerBuffer && this.y > height - cornerBuffer) {
            directions = ['left', 'up'];
        }

        if (directions.length === 0) {
            directions = ['up', 'down', 'left', 'right'];
        }

        const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };
        if (this.direction && this.directionChangeCount < 2) {
            directions = directions.filter(d => d !== opposites[this.direction]);
        }

        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
        this.directionChangeCount++;
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }

    cleanup() {
        super.cleanup();
        
        if (!this.isDisappearing) {
            this.isColliding = false;
            this.buttonInteractionAvailable = false;
            this.soundPlayed = false;
            this.currentSprite = null;
            this.activeSprite = null;
            this.hasInteracted = false;
        }
    }

    pauseUpdates() {
        super.pauseUpdates();
    }

    resumeUpdates() {
        super.resumeUpdates();
        this.moveTimer = performance.now();
        this.lastDirectionChange = performance.now();
        this.lastUpdateTime = performance.now();
        this.frameTime = performance.now();
    }
}










Suina2.js:
// Suina2.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class Suina2 extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 1.5);
        
        const now = performance.now();
        
        this.moveTimer = now;
        this.changeDirectionInterval = 2500;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = now;

        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.disappearanceTimer = null;
        this.canInteract = false;
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible) {
            return;
        }

        const isCollidingNow = this.checkCollision(player);

        // First collision detection


    if (isCollidingNow && !this.isColliding && !this.isDisappearing && !this.disappearanceTimer) {
        // Change to suina1-attack.png sprite
        if (this.sprites.attack) {
            this.currentSprite = 'attack';
            this.activeSprite = this.sprites.attack;  // This will be suina1-attack.png
            this.frame = 0;
        }

        const gameInstance = window.gameInstance;
        if (!this.soundPlayed && gameInstance?.audioManager) {
            gameInstance.audioManager.playSound('suina_sound');
            this.soundPlayed = true;
        }

        this.canInteract = true;

        // Set disappearance timer for 2 seconds
        this.disappearanceTimer = setTimeout(() => {
            this.startDisappearance();
        }, 2000);

        this.isColliding = true;
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        this.isIdle = true;
    }


        // Handle button interactions within the 2-second window
        if (this.canInteract && !this.isDisappearing) {
            const gameInstance = window.gameInstance;
            
            if (input.keys.KeyB) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('professore_smack');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 3);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
            else if (input.keys.KeyF) {
                if (gameInstance?.audioManager) {
                    gameInstance.audioManager.playSound('suina_fuck');
                    if (gameInstance.scoreManager) {
                        gameInstance.scoreManager.increaseScore('love', 6);
                    }
                }
                this.canInteract = false;
                if (this.disappearanceTimer) {
                    clearTimeout(this.disappearanceTimer);
                }
                this.startDisappearance();
            }
        }

        // Handle movement if not in collision or disappearing state
        if (!this.isColliding && !this.isDisappearing) {
            const distance = Math.hypot(player.x - this.x, player.y - this.y);
            if (distance < 150) {
                this.runAwayFrom(player, deltaTime, worldBounds);
                this.isIdle = false;
            } else {
                this.moveRandomly(deltaTime, worldBounds);
            }
        }
    }

    startDisappearance() {
        this.isDisappearing = true;
        this.isVisible = false;
        this.canInteract = false;
        
        // Clear any existing timer
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        if (this.levelManager) {
            this.levelManager.handleCharacterDisappear(this);
        }
    }

    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        const adjustedSpeed = this.speed * deltaTime * 1.2;

        const oldX = this.x;
        const oldY = this.y;

        const randomOffset = Math.random() * 0.2 - 0.1;
        const finalAngle = angle + randomOffset;

        this.x = Math.min(Math.max(this.x + Math.cos(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.width - this.width);
        this.y = Math.min(Math.max(this.y + Math.sin(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.height - this.height);

        if (this.x !== oldX || this.y !== oldY) {
            this.updateDirection(this.x - oldX, this.y - oldY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const oldX = this.x;
        const oldY = this.y;

        switch (this.direction) {
            case 'up':
                this.y = Math.max(this.y - adjustedSpeed, 0);
                break;
            case 'down':
                this.y = Math.min(this.y + adjustedSpeed, worldBounds.height - this.height);
                break;
            case 'left':
                this.x = Math.max(this.x - adjustedSpeed, 0);
                break;
            case 'right':
                this.x = Math.min(this.x + adjustedSpeed, worldBounds.width - this.width);
                break;
        }

        const moved = (Math.abs(this.x - oldX) > 0.01 || Math.abs(this.y - oldY) > 0.01);

        if (moved) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
            this.stuckTimer = 0;
        } else {
            this.stuckTimer += deltaTime * 16.67;
            if (this.stuckTimer > 1000) {
                this.randomizeDirection(worldBounds);
                this.stuckTimer = 0;
            }
        }
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }

    randomizeDirection(worldBounds) {
        const directions = ['up', 'down', 'left', 'right'];
        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
    }

    cleanup() {
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }
        this.canInteract = false;
        super.cleanup();
    }
}











SuinaEvil.js:
// SuinaEvil.js
import { BaseCharacter } from './BaseCharacter.js';
import { CONFIG } from '../config.js';

export class SuinaEvil extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type, 1.5);
        
        const now = performance.now();
        
        // Movement related properties
        this.moveTimer = now;
        this.changeDirectionInterval = 2500;
        this.lastNonIdleDirection = 'down';
        this.lastUpdateTime = now;
        this.frameTime = now;
        this.movementBuffer = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.lastX = x;
        this.lastY = y;
        this.stuckTimer = 0;
        this.directionChangeCount = 0;
        this.lastDirectionChange = now;

        // Animation and state properties
        this.frame = 0;
        this.isIdle = false;
        this.direction = 'down';
        this.currentSprite = 'walking';
        this.activeSprite = sprites?.walking;
        
        // Interaction states
        this.isColliding = false;
        this.isDisappearing = false;
        this.soundPlayed = false;
        this.isVisible = true;
        this.hasInteracted = false;
        this.canInteract = false;
        this.isGameOverTriggered = false;

        // Timers
        this.disappearanceTimer = null;
        this.interactionCooldown = null;
        this.gameOverAnimationInProgress = false;
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused || !this.isVisible || this.gameOverAnimationInProgress) {
            return;
        }

        const isCollidingNow = this.checkCollision(player);

        // First collision detection
        if (isCollidingNow && !this.isColliding && !this.isDisappearing) {
            this.handleInitialCollision();
        }

        // Handle button interactions
        if (this.canInteract && !this.isDisappearing) {
            this.handleInteraction(input, player);
        }

        // Handle movement if not in collision or disappearing state
        if (!this.isColliding && !this.isDisappearing) {
            this.handleMovement(player, deltaTime, worldBounds);
        }
    }

    handleInitialCollision() {
        // Change to attack sprite
        if (this.sprites.attack) {
            this.currentSprite = 'attack';
            this.activeSprite = this.sprites.attack;
            this.frame = 0;
        }

        // Play initial collision sound
        const gameInstance = window.gameInstance;
        if (!this.soundPlayed && gameInstance?.audioManager) {
            gameInstance.audioManager.playSound('suina_sound');
            this.soundPlayed = true;
        }

        // Set up interaction window
        this.canInteract = true;
        this.isColliding = true;
        
        // Reset movement
        this.velocity = { x: 0, y: 0 };
        this.movementBuffer = { x: 0, y: 0 };
        this.isIdle = true;

        // Set disappearance timer
        this.disappearanceTimer = setTimeout(() => {
            this.startDisappearance();
        }, 2000);
    }


handleInteraction(input, player) {
    const gameInstance = window.gameInstance;
    
    if (input.keys.KeyB) {
        if (gameInstance?.audioManager) {
            console.log('buzz');
            gameInstance.audioManager.playSound('buzz');

            if (gameInstance.scoreManager) {
                // Use the centralized message system
                if (gameInstance.renderer) {
                    gameInstance.renderer.showSuinaMalaMessage();
                }
                gameInstance.scoreManager.increaseScore('love', -5);
                gameInstance.scoreManager.scoreAnimation.addAnimation(5, true);
            }
        }

        this.triggerDisappearance();
    }
    else if (input.keys.KeyF && !this.isGameOverTriggered) {
        this.triggerGameOver(player);
    }
}

triggerGameOver(player) {
    const gameInstance = window.gameInstance;
    if (!gameInstance) return;

    this.isGameOverTriggered = true;
    this.gameOverAnimationInProgress = true;

    // Play evil sound effect
    if (gameInstance.audioManager) {
        gameInstance.audioManager.playSound('buzz');  // Added buzz sound back
        gameInstance.audioManager.playSound('suina_evil');
    }

    // Trigger game over sequence
    if (gameInstance.gameState) {
        gameInstance.gameState.triggerJailGameOver(player);
    }

    // Show game over message sequence
    if (gameInstance.renderer) {
        gameInstance.renderer.showGameOverMessage();
    }

    // Clean up interaction state
    this.canInteract = false;
    if (this.disappearanceTimer) {
        clearTimeout(this.disappearanceTimer);
    }

    // Start disappearance after game over animation
    setTimeout(() => {
        this.gameOverAnimationInProgress = false;
        this.startDisappearance();
    }, 2000);
}




    triggerDisappearance() {
        this.canInteract = false;
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
        }
        this.startDisappearance();
    }

    startDisappearance() {
        if (this.isDisappearing) return;
        
        this.isDisappearing = true;
        this.isVisible = false;
        this.canInteract = false;
        
        // Clear any existing timer
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }

        // Notify level manager
        if (this.levelManager) {
            this.levelManager.handleCharacterDisappear(this);
        }
    }

    handleMovement(player, deltaTime, worldBounds) {
        const distance = Math.hypot(player.x - this.x, player.y - this.y);
        if (distance < 150) {
            this.runAwayFrom(player, deltaTime, worldBounds);
            this.isIdle = false;
        } else {
            this.moveRandomly(deltaTime, worldBounds);
        }
    }

    runAwayFrom(player, deltaTime, worldBounds) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const angle = Math.atan2(dy, dx);
        const adjustedSpeed = this.speed * deltaTime * 1.2;

        const oldX = this.x;
        const oldY = this.y;

        const randomOffset = Math.random() * 0.2 - 0.1;
        const finalAngle = angle + randomOffset;

        this.x = Math.min(Math.max(this.x + Math.cos(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.width - this.width);
        this.y = Math.min(Math.max(this.y + Math.sin(finalAngle) * adjustedSpeed, 0), 
                         worldBounds.height - this.height);

        if (this.x !== oldX || this.y !== oldY) {
            this.updateDirection(this.x - oldX, this.y - oldY);
            this.isIdle = false;
            this.stuckTimer = 0;
        }
    }

    moveRandomly(deltaTime, worldBounds) {
        const adjustedSpeed = this.speed * deltaTime * 0.8;
        const oldX = this.x;
        const oldY = this.y;

        switch (this.direction) {
            case 'up':
                this.y = Math.max(this.y - adjustedSpeed, 0);
                break;
            case 'down':
                this.y = Math.min(this.y + adjustedSpeed, worldBounds.height - this.height);
                break;
            case 'left':
                this.x = Math.max(this.x - adjustedSpeed, 0);
                break;
            case 'right':
                this.x = Math.min(this.x + adjustedSpeed, worldBounds.width - this.width);
                break;
        }

        const moved = (Math.abs(this.x - oldX) > 0.01 || Math.abs(this.y - oldY) > 0.01);

        if (moved) {
            this.isIdle = false;
            this.lastNonIdleDirection = this.direction;
            this.stuckTimer = 0;
        } else {
            this.stuckTimer += deltaTime * 16.67;
            if (this.stuckTimer > 1000) {
                this.randomizeDirection(worldBounds);
                this.stuckTimer = 0;
            }
        }
    }

    updateDirection(dx, dy) {
        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        this.lastNonIdleDirection = this.direction;
    }

    randomizeDirection(worldBounds) {
        const directions = ['up', 'down', 'left', 'right'];
        const newDirection = directions[Math.floor(Math.random() * directions.length)];
        this.direction = newDirection;
        this.lastNonIdleDirection = newDirection;
        this.isIdle = false;
    }

    cleanup() {
        if (this.disappearanceTimer) {
            clearTimeout(this.disappearanceTimer);
            this.disappearanceTimer = null;
        }
        if (this.interactionCooldown) {
            clearTimeout(this.interactionCooldown);
            this.interactionCooldown = null;
        }
        this.canInteract = false;
        this.isGameOverTriggered = false;
        this.gameOverAnimationInProgress = false;
        super.cleanup();
    }
}








Diego.js:
// Diego.js
import { BaseCharacter } from './BaseCharacter.js';

export class Diego extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
        this.lastBehaviorUpdate = performance.now();
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused) return;
        
        const currentTime = performance.now();
        this.lastBehaviorUpdate = currentTime;
        
        // Currently remains idle - future behavior can be added here
        this.isIdle = true;
        this.direction = 'down';
    }
}





Milly.js:
// Milly.js
import { BaseCharacter } from './BaseCharacter.js';

export class Milly extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
        this.lastBehaviorUpdate = performance.now();
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused) return;
        
        const currentTime = performance.now();
        this.lastBehaviorUpdate = currentTime;
        
        // Currently remains idle - future behavior can be added here
        this.isIdle = true;
        this.direction = 'down';
    }
}





Walter.js:
// Walter.js
import { BaseCharacter } from './BaseCharacter.js';

export class Walter extends BaseCharacter {
    constructor(x, y, width, height, sprites, type) {
        super(x, y, width, height, sprites, type);
        this.lastBehaviorUpdate = performance.now();
    }

    updateBehavior(player, worldBounds, deltaTime, input) {
        if (this.isPaused) return;
        
        const currentTime = performance.now();
        this.lastBehaviorUpdate = currentTime;
        
        // Currently remains idle - future behavior can be added here
        this.isIdle = true;
        this.direction = 'down';
    }
}






